<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Binary Structured HTTP Field Values</title><script>
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><meta property="og:type" content="article"><meta property="og:title" content="Binary Structured HTTP Field Values"><meta property="og:description" content="This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2."><meta property="og:url" content="https://mnot.github.io/I-D/binary-structured-headers/"><meta property="og:site_name" content="mnot's Internet Drafts"><link rel="stylesheet" type="text/css" href="../Tools/style.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #sidebar {
        margin-top: -10px;
        height: 90%;
        overflow-y: auto;
        font-size: 90%;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      .toc ul {
        list-style: none;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1, h2, h3 {
        margin-top: 1.2em;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="License" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Binary Structured Fields" href="#rfc.section.2"><link rel="Chapter" title="3 Using Binary Structured Fields in HTTP/2" href="#rfc.section.3"><link rel="Chapter" title="4 IANA Considerations" href="#rfc.section.4"><link rel="Chapter" title="5 Security Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 References" href="#rfc.section.6"><meta name="viewport" content="initial-scale=1"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-nottingham-binary-structured-headers-03"><meta name="dcterms.issued" content="2021-10-05"><meta name="dcterms.abstract" content="This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2."><meta name="description" content="This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2."></head><body><script async="True" defer="True" src="https://hypothes.is/embed.js"></script><div class="container" id="top"><div class="row"><div class="col-lg-4 order-last d-none d-lg-block" id="sidebar" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top"></a></div><br clear="all"><div class=""><div class="toc "><ul><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#fields">Binary Structured Fields</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#binlit">Binary Representations</a><ul><li><a href="#rfc.section.2.1.1">2.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#literal">Binary Literal Field Values</a></li><li><a href="#rfc.section.2.1.2">2.1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#list-field-values">List Field Values</a></li><li><a href="#rfc.section.2.1.3">2.1.3.</a>&nbsp;&nbsp;&nbsp;<a href="#dictionary-field-values">Dictionary Field Values</a></li><li><a href="#rfc.section.2.1.4">2.1.4.</a>&nbsp;&nbsp;&nbsp;<a href="#item-field-values">Item Field Values</a></li></ul></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#types">Binary Data Types</a><ul><li><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#inner-list">Inner Lists</a></li><li><a href="#rfc.section.2.2.2">2.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#parameter">Parameters</a></li><li><a href="#rfc.section.2.2.3">2.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#integers">Integers</a></li><li><a href="#rfc.section.2.2.4">2.2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#floats">Floats</a></li><li><a href="#rfc.section.2.2.5">2.2.5.</a>&nbsp;&nbsp;&nbsp;<a href="#strings">Strings</a></li><li><a href="#rfc.section.2.2.6">2.2.6.</a>&nbsp;&nbsp;&nbsp;<a href="#token">Tokens</a></li><li><a href="#rfc.section.2.2.7">2.2.7.</a>&nbsp;&nbsp;&nbsp;<a href="#byte-sequences">Byte Sequences</a></li><li><a href="#rfc.section.2.2.8">2.2.8.</a>&nbsp;&nbsp;&nbsp;<a href="#booleans">Booleans</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#negotiate">Using Binary Structured Fields in HTTP/2</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#setting">The SETTINGS_BINARY_STRUCTURED_FIELDS Setting</a></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#flag">The BINARY_STRUCTRED HEADERS Flag</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">Normative References</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div></div></div></div><div class="col-lg-8 order-first main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Network Working Group</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">October 5, 2021</td></tr><tr><td class="text-left">Intended status: Standards Track</td><td class="text-right"></td></tr><tr><td class="text-left">Expires: April 8, 2022</td><td class="text-right"></td></tr></tbody></table><div id="rfc.title"><h1>Binary Structured HTTP Field Values</h1><div class="filename"><a href="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers" class="smpl">draft-nottingham-binary-structured-headers</a>-<a href="https://tools.ietf.org/html/draft-nottingham-binary-structured-headers-03" class="smpl">03</a></div></div></header><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><div id="rfc.abstract.p.1"><p>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</p></div></div><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p><em>RFC EDITOR: please remove this section before publication</em></p></div><div id="rfc.note.1.p.2"><p>The issues list for this draft can be found at <a href="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</a>.</p></div><div id="rfc.note.1.p.3"><p>The most recent (often, unpublished) draft is at <a href="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</a>.</p></div><div id="rfc.note.1.p.4"><p>Recent changes are listed at <a href="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</a>.</p></div><div id="rfc.note.1.p.5"><p>See also the draft's current status in the IETF datatracker, at <a href="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on April 8, 2022.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2021 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><div class="toc d-lg-none"><ul><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#fields">Binary Structured Fields</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#binlit">Binary Representations</a><ul><li><a href="#rfc.section.2.1.1">2.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#literal">Binary Literal Field Values</a></li><li><a href="#rfc.section.2.1.2">2.1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#list-field-values">List Field Values</a></li><li><a href="#rfc.section.2.1.3">2.1.3.</a>&nbsp;&nbsp;&nbsp;<a href="#dictionary-field-values">Dictionary Field Values</a></li><li><a href="#rfc.section.2.1.4">2.1.4.</a>&nbsp;&nbsp;&nbsp;<a href="#item-field-values">Item Field Values</a></li></ul></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#types">Binary Data Types</a><ul><li><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#inner-list">Inner Lists</a></li><li><a href="#rfc.section.2.2.2">2.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#parameter">Parameters</a></li><li><a href="#rfc.section.2.2.3">2.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#integers">Integers</a></li><li><a href="#rfc.section.2.2.4">2.2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#floats">Floats</a></li><li><a href="#rfc.section.2.2.5">2.2.5.</a>&nbsp;&nbsp;&nbsp;<a href="#strings">Strings</a></li><li><a href="#rfc.section.2.2.6">2.2.6.</a>&nbsp;&nbsp;&nbsp;<a href="#token">Tokens</a></li><li><a href="#rfc.section.2.2.7">2.2.7.</a>&nbsp;&nbsp;&nbsp;<a href="#byte-sequences">Byte Sequences</a></li><li><a href="#rfc.section.2.2.8">2.2.8.</a>&nbsp;&nbsp;&nbsp;<a href="#booleans">Booleans</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#negotiate">Using Binary Structured Fields in HTTP/2</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#setting">The SETTINGS_BINARY_STRUCTURED_FIELDS Setting</a></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#flag">The BINARY_STRUCTRED HEADERS Flag</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">Normative References</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>Structured Field Values for HTTP <a href="#STRUCTURED-FIELDS"><cite title="Structured Field Values for HTTP">[STRUCTURED-FIELDS]</cite></a> offers a set of data types that new fields can use to express their semantics in a familiar textual syntax. This specification defines an alternative, binary serialisation of those structures in <a href="#fields" title="Binary Structured Fields">Section&nbsp;2</a>, and specifies its use in HTTP/2 in <a href="#negotiate" title="Using Binary Structured Fields in HTTP/2">Section&nbsp;3</a>.</p></div><div id="rfc.section.1.p.2"><p>The primary goal is to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div><div id="rfc.section.1.1.p.2"><p>This specification describes formats using the convention described in <a href="https://tools.ietf.org/html/rfc9001#section-1.3">Section 1.3</a> of <a href="#QUIC"><cite title="Using TLS to Secure QUIC">[QUIC]</cite></a>.</p></div></section></section><section id="fields"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#fields">Binary Structured Fields</a></h2><div id="rfc.section.2.p.1"><p>This section defines a binary serialisation for the Structured Field Types defined in <a href="#STRUCTURED-FIELDS"><cite title="Structured Field Values for HTTP">[STRUCTURED-FIELDS]</cite></a>.</p></div><div id="rfc.section.2.p.2"><p>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Representation (<a href="#binlit" title="Binary Representations">Section&nbsp;2.1</a>), which is a replacement for the String Literal Representation in <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>.</p></div><div id="rfc.section.2.p.3"><p>Binary representations of the remaining structured field types are defined in <a href="#types" title="Binary Data Types">Section&nbsp;2.2</a>.</p></div><section id="binlit"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a href="#binlit">Binary Representations</a></h3><div id="rfc.section.2.1.p.1"><p>Binary Representations are a replacement for the String Literal Representation defined in <a href="https://tools.ietf.org/html/rfc7541#section-5.2">Section 5.2</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, and can be used to serialise any field, including but not limited to those defined as Structured Fields.</p></div><div id="rfc.section.2.1.p.2" class="avoidbreakafter"><p>All Binary Representations share the following header:</p></div><div id="rfc.section.2.1.p.3"><pre>
Binary Representation {
  Top Level Type (3),
  Length (5..),
}
</pre></div><div id="rfc.section.2.1.p.4" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.1.p.5"><ul><li>Top Level Type: Three bits indicating the top-level type of the field value.</li><li>Length: The number of octets used to represent the entire field value (including the header), encoded as per <a href="https://tools.ietf.org/html/rfc7541#section-5.1">Section 5.1</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, with a 5-bit prefix.</li></ul></div><div id="rfc.section.2.1.p.6" class="avoidbreakafter"><p>The following top-level types are defined:</p></div><section id="literal"><h4 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1.</a>&nbsp;<a href="#literal">Binary Literal Field Values</a></h4><div id="rfc.section.2.1.1.p.1"><p>Binary Literal field values (type=0x0) carry the string value of a field; they are used to carry field values that are not structured using the data types defined in <a href="https://tools.ietf.org/html/rfc8941#section-3">Section 3</a> of <a href="#STRUCTURED-FIELDS"><cite title="Structured Field Values for HTTP">[STRUCTURED-FIELDS]</cite></a>. This might be because the field is not recognised as a Structured Field, or it might be because a field that is understood to be a Structured Field cannot be parsed successfully as one.</p></div><div id="rfc.section.2.1.1.p.2"><p>A binary literal field value's payload is the raw octets of the field value. As such, they are functionally equivalent to String Literal Representations in <a href="https://tools.ietf.org/html/rfc7541#section-5.2">Section 5.2</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>.</p></div><div id="rfc.section.2.1.1.p.3"><pre>
Binary Literal Field Value {
  Top Level Type (3) = 0,
  Length (5..),
  Payload (..)
}
</pre></div></section><section id="list-field-values"><h4 id="rfc.section.2.1.2"><a href="#rfc.section.2.1.2">2.1.2.</a>&nbsp;<a href="#list-field-values">List Field Values</a></h4><div id="rfc.section.2.1.2.p.1"><p>Structured fields whose values are known to be a List as per <a href="https://tools.ietf.org/html/rfc8941#section-3.1">Section 3.1</a> of <a href="#STRUCTURED-FIELDS"><cite title="Structured Field Values for HTTP">[STRUCTURED-FIELDS]</cite></a> can be conveyed as a binary representation with a top level type of 0x1. They have a payload consisting of one or more Binary Data Types (<a href="#types" title="Binary Data Types">Section&nbsp;2.2</a>) representing the members of the list.</p></div><div id="rfc.section.2.1.2.p.2"><pre>
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Binary Data Type (..) ...
}
</pre></div></section><section id="dictionary-field-values"><h4 id="rfc.section.2.1.3"><a href="#rfc.section.2.1.3">2.1.3.</a>&nbsp;<a href="#dictionary-field-values">Dictionary Field Values</a></h4><div id="rfc.section.2.1.3.p.1"><p>Structured fields whose values are known to be a Dictionary as per <a href="https://tools.ietf.org/html/rfc8941#section-3.2">Section 3.2</a> of <a href="#STRUCTURED-FIELDS"><cite title="Structured Field Values for HTTP">[STRUCTURED-FIELDS]</cite></a> can be conveyed in a binary representation with a top level type of 0x2. They have a payload consisting of one or more Dictionary Members.</p></div><div id="rfc.section.2.1.3.p.2"><pre>
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
</pre></div><div id="rfc.section.2.1.3.p.3"><p>Each Dictionary member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Data Type(s) representing the member-value.</p></div><div id="rfc.section.2.1.3.p.4"><pre>
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Binary Data Type (..),
  [Parameters (..)]
}

</pre></div><div id="rfc.section.2.1.3.p.5"><p>The Binary Data Type in a Dictionary Member MUST NOT be a Parameters (0x2).</p></div></section><section id="item-field-values"><h4 id="rfc.section.2.1.4"><a href="#rfc.section.2.1.4">2.1.4.</a>&nbsp;<a href="#item-field-values">Item Field Values</a></h4><div id="rfc.section.2.1.4.p.1"><p>Structured field values that are known to be an Item as per <a href="https://tools.ietf.org/html/rfc8941#section-3.3">Section 3.3</a> of <a href="#STRUCTURED-FIELDS"><cite title="Structured Field Values for HTTP">[STRUCTURED-FIELDS]</cite></a> can be conveyed in a binary representation with a top level type of 0x3. They have a payload consisting of a single Binary Data Type (<a href="#types" title="Binary Data Types">Section&nbsp;2.2</a>), with optional parameters (<a href="#parameter" title="Parameters">Section&nbsp;2.2.2</a>).</p></div><div id="rfc.section.2.1.4.p.2"><pre>
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Binary Data Type (..),
  [Parameters (..)]
}
</pre></div><div id="rfc.section.2.1.4.p.3"><p>The Binary Data Type in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</p></div></section></section><section id="types"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a>&nbsp;<a href="#types">Binary Data Types</a></h3><div id="rfc.section.2.2.p.1"><p>Binary data types are discrete values that are composed into binary representations (<a href="#binlit" title="Binary Representations">Section&nbsp;2.1</a>) to represent the structured field values.</p></div><div id="rfc.section.2.2.p.2"><p>Every binary data type starts with a 4-bit type field that identifies the format of its payload.</p></div><div id="rfc.section.2.2.p.3"><pre>
Binary Data Type {
  Type (4)
}
</pre></div><div id="rfc.section.2.2.p.4"><p>Some data types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</p></div><section id="inner-list"><h4 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;<a href="#inner-list">Inner Lists</a></h4><div id="rfc.section.2.2.1.p.1" class="avoidbreakafter"><p>The Inner List data type (type=0x1) has a payload in the format:</p></div><div id="rfc.section.2.2.1.p.2"><pre>
Inner List {
  Type (4) = 1,
  Length (4..),
  Binary Data Type (..) ...
}
</pre></div><div id="rfc.section.2.2.1.p.3"><p>Length conveys the number of octets used to represent the inner list, encoded as per <a href="https://tools.ietf.org/html/rfc7541#section-5.1">Section 5.1</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, with a 4-bit prefix.</p></div><div id="rfc.section.2.2.1.p.4"><p>A Binary Data Type in an Inner List MUST NOT be an Inner List (0x1).</p></div><div id="rfc.section.2.2.1.p.5"><p>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<a href="#parameter" title="Parameters">Section&nbsp;2.2.2</a>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</p></div></section><section id="parameter"><h4 id="rfc.section.2.2.2"><a href="#rfc.section.2.2.2">2.2.2.</a>&nbsp;<a href="#parameter">Parameters</a></h4><div id="rfc.section.2.2.2.p.1" class="avoidbreakafter"><p>The Parameters data type (type=0x2) has a payload in the format:</p></div><div id="rfc.section.2.2.2.p.2"><pre>
Parameters {
  Type (4) = 2,
  Length (4..),
  Parameter (..) ...
}
</pre></div><div id="rfc.section.2.2.2.p.3"><p>Length conveys the number of octets used to represent the parameters, encoded as per <a href="https://tools.ietf.org/html/rfc7541#section-5.1">Section 5.1</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, with a 4-bit prefix.</p></div><div id="rfc.section.2.2.2.p.4" class="avoidbreakafter"><p>Each Parameter conveys a key and a value:</p></div><div id="rfc.section.2.2.2.p.5"><pre>
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Binary Data Type (..)
}
</pre></div><div id="rfc.section.2.2.2.p.6" class="avoidbreakafter"><p>A parameter's fields are:</p></div><div id="rfc.section.2.2.2.p.7"><ul><li>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <a href="https://tools.ietf.org/html/rfc7541#section-5.1">Section 5.1</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, with a 8-bit prefix</li><li>Parameter Name: Parameter Name Length octets of the parameter-name</li><li>Binary Data Type: The parameter value, a Binary Data Type</li></ul></div><div id="rfc.section.2.2.2.p.8"><p>The Binary Data Type in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</p></div><div id="rfc.section.2.2.2.p.9"><p>Parameters are always associated with the Binary Data Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Binary Data Type in a Binary Representation, and MUST NOT follow another Parameters.</p></div></section><section id="integers"><h4 id="rfc.section.2.2.3"><a href="#rfc.section.2.2.3">2.2.3.</a>&nbsp;<a href="#integers">Integers</a></h4><div id="rfc.section.2.2.3.p.1" class="avoidbreakafter"><p>The Integer data type (type=0x3) has a payload in the format:</p></div><div id="rfc.section.2.2.3.p.2"><pre>
Integer {
  Type (4) = 3,
  Sign (1),
  Payload (3..)
}
</pre></div><div id="rfc.section.2.2.3.p.3" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.2.3.p.4"><ul><li>Sign: sign bit; 0 is negative, 1 is positive</li><li>Payload: The integer, encoded as per <a href="https://tools.ietf.org/html/rfc7541#section-5.1">Section 5.1</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, with a 2-bit prefix</li></ul></div></section><section id="floats"><h4 id="rfc.section.2.2.4"><a href="#rfc.section.2.2.4">2.2.4.</a>&nbsp;<a href="#floats">Floats</a></h4><div id="rfc.section.2.2.4.p.1" class="avoidbreakafter"><p>The Float data type (type=0x4) have a payload in the format:</p></div><div id="rfc.section.2.2.4.p.2"><pre>
Float {
  Type (4) = 4,
  Sign (1),
  Integer (3..),
  Fractional (8..)
}
</pre></div><div id="rfc.section.2.2.4.p.3" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.2.4.p.4"><ul><li>Sign: sign bit; 0 is negative, 1 is positive</li><li>Integer: The integer component, encoded as per <a href="https://tools.ietf.org/html/rfc7541#section-5.1">Section 5.1</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, with a 2-bit prefix.</li><li>Fractional: The fractional component, encoded as per <a href="https://tools.ietf.org/html/rfc7541#section-5.1">Section 5.1</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, with a 8-bit prefix.</li></ul></div></section><section id="strings"><h4 id="rfc.section.2.2.5"><a href="#rfc.section.2.2.5">2.2.5.</a>&nbsp;<a href="#strings">Strings</a></h4><div id="rfc.section.2.2.5.p.1" class="avoidbreakafter"><p>The String data type (type=0x5) has a payload in the format:</p></div><div id="rfc.section.2.2.5.p.2"><pre>
String {
  Type (4) = 5,
  Length (4..),
  Payload (..)
}
</pre></div><div id="rfc.section.2.2.5.p.3"><p>Its payload is Length octets long and ASCII-encoded.</p></div></section><section id="token"><h4 id="rfc.section.2.2.6"><a href="#rfc.section.2.2.6">2.2.6.</a>&nbsp;<a href="#token">Tokens</a></h4><div id="rfc.section.2.2.6.p.1" class="avoidbreakafter"><p>The Token data type (type=0x6) has a payload in the format:</p></div><div id="rfc.section.2.2.6.p.2"><pre>
Token {
  Type (4) = 6,
  Length (4..),
  Payload (..)
}
</pre></div><div id="rfc.section.2.2.6.p.3"><p>Its payload is Length octets long and ASCII-encoded.</p></div></section><section id="byte-sequences"><h4 id="rfc.section.2.2.7"><a href="#rfc.section.2.2.7">2.2.7.</a>&nbsp;<a href="#byte-sequences">Byte Sequences</a></h4><div id="rfc.section.2.2.7.p.1" class="avoidbreakafter"><p>The Byte Sequence data type (type=0x7) has a payload in the format:</p></div><div id="rfc.section.2.2.7.p.2"><pre>
Byte Sequence {
  Type (4) = 7,
  Length (4..),
  Payload (..)
}
</pre></div><div id="rfc.section.2.2.7.p.3"><p>The payload is is Length octets long, containing the raw octets of the byte sequence.</p></div></section><section id="booleans"><h4 id="rfc.section.2.2.8"><a href="#rfc.section.2.2.8">2.2.8.</a>&nbsp;<a href="#booleans">Booleans</a></h4><div id="rfc.section.2.2.8.p.1" class="avoidbreakafter"><p>The Boolean data type (type=0x8) has a payload of two bits:</p></div><div id="rfc.section.2.2.8.p.2"><pre>
Boolean {
  Type (4) = 8,
  Payload (1),
  Padding (3) = 0
}
</pre></div><div id="rfc.section.2.2.8.p.3"><p>If Payload is 0, the value is False; if Payload is 1, the value is True.</p></div></section></section></section><section id="negotiate"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#negotiate">Using Binary Structured Fields in HTTP/2</a></h2><div id="rfc.section.3.p.1"><p>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields as binary data, rather than strings.</p></div><div id="rfc.section.3.p.2"><p>Peers advertise and discover this support using a HTTP/2 setting defined in <a href="#setting" title="The SETTINGS_BINARY_STRUCTURED_FIELDS Setting">Section&nbsp;3.1</a>, and convey Binary Structured Fields in streams whose HEADERS frame uses the flag defined in <a href="#flag" title="The BINARY_STRUCTRED HEADERS Flag">Section&nbsp;3.2</a>.</p></div><section id="setting"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a>&nbsp;<a href="#setting">The SETTINGS_BINARY_STRUCTURED_FIELDS Setting</a></h3><div id="rfc.section.3.1.p.1"><p>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</p></div><div id="rfc.section.3.1.p.2" class="avoidbreakafter"><p>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS with a non-zero value from a peer indicates that:</p></div><div id="rfc.section.3.1.p.3"><ol type="1"><li>The peer supports all of the Binary Data Types defined in <a href="#fields" title="Binary Structured Fields">Section&nbsp;2</a>.</li><li>The peer will process the BINARY_STRUCTRED HEADERS flag as defined in <a href="#flag" title="The BINARY_STRUCTRED HEADERS Flag">Section&nbsp;3.2</a>.</li><li><div class="avoidbreakafter"><p>When passing the message to a downstream consumer (whether on the network or not), the peer will:</p></div> <div><ol type="1"><li>Transform all fields defined as Mapped Fields in Section 1.3 of <a href="#RETROFIT"><cite title="Retrofit Structured Fields for HTTP">[RETROFIT]</cite></a> into their unmapped forms, removing the mapped fields.</li><li>Transform the message fields into the appropriate form for that peer (e.g., the textual representation of Structured Fields data types defined in <a href="#STRUCTURED-FIELDS"><cite title="Structured Field Values for HTTP">[STRUCTURED-FIELDS]</cite></a>).</li></ol></div> </li></ol></div><div id="rfc.section.3.1.p.4"><p>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0, whereas a value of 1 indicates that this specification is supported with no further extensions. Future specifications might use values greater than one to indicate support for extensions.</p></div></section><section id="flag"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a>&nbsp;<a href="#flag">The BINARY_STRUCTRED HEADERS Flag</a></h3><div id="rfc.section.3.2.p.1"><p>When a peer has indicated that it supports this specification as per <a href="#setting" title="The SETTINGS_BINARY_STRUCTURED_FIELDS Setting">Section&nbsp;3.1</a>, a sender can send the BINARY_STRUCTURED flag (0xTODO) on the HEADERS frame.</p></div><div id="rfc.section.3.2.p.2"><p>This flag indicates that the HEADERS frame containing it and subsequent CONTINUATION frames on the same stream use the Binary Representation defined in <a href="#binlit" title="Binary Representations">Section&nbsp;2.1</a> instead of the String Literal Representation defined in <a href="https://tools.ietf.org/html/rfc7541#section-5.2">Section 5.2</a> of <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a> for all field values. Field names are still serialised as String Literal Representations.</p></div><div id="rfc.section.3.2.p.3"><p>In such frames, field values that are known to be Structured Fields and those that can be converted to Structured Fields (as per <a href="#RETROFIT"><cite title="Retrofit Structured Fields for HTTP">[RETROFIT]</cite></a>) MAY be sent using the applicable Binary Representation. However, any field value (including those defined as Structured Fields) can also be serialised as a Binary Literal (<a href="#literal" title="Binary Literal Field Values">Section&nbsp;2.1.1</a>) to accommodate fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as a Structured Field for some other reason.</p></div><div id="rfc.section.3.2.p.4"><p>Binary Representations are stored in the HPACK <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a> dynamic table, and their lengths are used for the purposes of maintaining dynamic table size (see <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, <a href="https://tools.ietf.org/html/rfc7541#section-4">Section 4</a>).</p></div><div id="rfc.section.3.2.p.5"><p>Note that HEADERS frames with and without the BINARY_STRUCTURED flag MAY be mixed on the same connection, depending on the requirements of the sender.</p></div></section></section><section id="iana-considerations"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.4.p.1"><ul><li>ISSUE: todo</li></ul></div></section><section id="security-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.5.p.1"><p>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</p></div><div id="rfc.section.5.p.2"><p>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of Binary Literals (<a href="#literal" title="Binary Literal Field Values">Section&nbsp;2.1.1</a>). Therefore, implementation divergence from this strictness can have security impact.</p></div></section><section><div id="rfc.references"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a> Normative References</h2><dl class="dl-horizontal"><dt id="QUIC">[QUIC]</dt><dd>Thomson, M., Ed. and S. Turner, Ed., “<a href="https://tools.ietf.org/html/rfc9001">Using TLS to Secure QUIC</a>”, RFC&nbsp;9001, <a href="http://dx.doi.org/10.17487/RFC9001">DOI&nbsp;10.17487/RFC9001</a>, May&nbsp;2021, &lt;<a href="https://www.rfc-editor.org/info/rfc9001">https://www.rfc-editor.org/info/rfc9001</a>&gt;.</dd><dt id="RETROFIT">[RETROFIT]</dt><dd>Nottingham, M., “<a href="https://mnot.github.io/I-D/http-structure-retrofit/">Retrofit Structured Fields for HTTP</a>”, October&nbsp;2021, &lt;<a href="https://mnot.github.io/I-D/http-structure-retrofit/">https://mnot.github.io/I-D/http-structure-retrofit/</a>&gt;.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC7541">[RFC7541]</dt><dd>Peon, R. and H. Ruellan, “<a href="https://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>”, RFC&nbsp;7541, <a href="http://dx.doi.org/10.17487/RFC7541">DOI&nbsp;10.17487/RFC7541</a>, May&nbsp;2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7541">https://www.rfc-editor.org/info/rfc7541</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., “<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>”, BCP&nbsp;14, RFC&nbsp;8174, <a href="http://dx.doi.org/10.17487/RFC8174">DOI&nbsp;10.17487/RFC8174</a>, May&nbsp;2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd><dt id="STRUCTURED-FIELDS">[STRUCTURED-FIELDS]</dt><dd>Nottingham, M. and P-H. Kamp, “<a href="https://tools.ietf.org/html/rfc8941">Structured Field Values for HTTP</a>”, RFC&nbsp;8941, <a href="http://dx.doi.org/10.17487/RFC8941">DOI&nbsp;10.17487/RFC8941</a>, February&nbsp;2021, &lt;<a href="https://www.rfc-editor.org/info/rfc8941">https://www.rfc-editor.org/info/rfc8941</a>&gt;.</dd></dl></div></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Author's Address</a></h2><address><b>Mark Nottingham</b><br>Prahran<br>VIC<br>Australia<br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></address></section></div></div></div><script src="../Tools/node_modules/jquery/dist/jquery.min.js"></script><script src="../Tools/node_modules/bootstrap/dist/js/bootstrap.min.js"></script></body></html>