<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-binary-structured-headers-03" category="std">

  <front>
    <title>Binary Structured HTTP Field Values</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <postal>
          <postalLine>Prahran</postalLine> <postalLine>VIC</postalLine>
          <postalLine>Australia</postalLine>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</t>

<t>It also defines how to use Structured Fields for many existing fields -- thereby "backporting" them -- when supported by both peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><em>RFC EDITOR: please remove this section before publication</em></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>

<t>See also the draft's current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction"><name>Introduction</name>

<t>Structured Field Values for HTTP <xref target="RFC8941"/> offers a set of data types that new fields can combine to express their semantics. This specification defines a binary serialisation of those structures in <xref target="fields"/>, and specifies its use in HTTP/2 in <xref target="negotiate"/>.</t>

<t>Additionally, <xref target="backport"/> defines how to convey existing fields as Structured Fields, when supported by two peers.</t>

<t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</t>

<section anchor="notational-conventions"><name>Notational Conventions</name>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This specification describes formats using the convention described in <xref section="1.3" sectionFormat="of" target="I-D.ietf-quic-transport"/>.</t>

</section>
</section>
<section anchor="fields"><name>Binary Structured Fields</name>

<t>This section defines a binary serialisation for the Structured Field Types defined in <xref target="RFC8941"/>.</t>

<t>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Representation (<xref target="binlit"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541"/>.</t>

<t>Binary representations of the remaining structured field types are defined in <xref target="types"/>.</t>

<section anchor="binlit"><name>Binary Representations</name>

<t>Binary Representations are a replacement for the String Literal Representation defined in <xref section="5.2." sectionFormat="of" target="RFC7541"/>, and can be used to serialise a Structured Field Type.</t>

<t>All Binary Representations share the following header:</t>

<figure><artwork><![CDATA[
Binary Representation {
  Top Level Type (3),
  Length (5..),
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Top Level Type: Three bits indicating the top-level type of the field value.</t>
  <t>Length: The number of octets used to represent the payload, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 5-bit prefix.</t>
</list></t>

<t>The following top-level types are defined:</t>

<section anchor="list-field-values"><name>List Field Values</name>

<t>List values (type=0x1) have a payload consisting of a stream of Binary Item Types representing the members of the list. Members that are Items are represented as per <xref target="types"/>; members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<figure><artwork><![CDATA[
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Item (..) ...
}
]]></artwork></figure>

<t>A List Field Value's fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the entire List, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 5-bit prefix</t>
  <t>Item: One or more Item(s) (<xref target="types"/>)</t>
</list></t>

</section>
<section anchor="dictionary-field-values"><name>Dictionary Field Values</name>

<t>Dictionary values (type=0x2) have a payload consisting of a stream of Dictionary Members.</t>

<t>Each member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Item Type(s) representing the member-value.</t>

<figure><artwork><![CDATA[
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
]]></artwork></figure>

<t>A Dictionary Field Value's fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the entire Dictionary, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 5-bit prefix</t>
  <t>Dictionary Member: one or more Dictionary Member(s)</t>
</list></t>

<figure><artwork><![CDATA[
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Item (..),
  [Parameters (..)]
}

]]></artwork></figure>

<t>A Dictionary Member's fields are:</t>

<t><list style="symbols">
  <t>Name Length: The number of octets used to represent the Member Name, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 8-bit prefix</t>
  <t>Member Name: Name Length octets of the member-name, ASCII-encoded</t>
  <t>Item: An Item (<xref target="types"/>)</t>
  <t>Parameters: Optional Parameters (<xref target="parameter"/>)</t>
</list></t>

<t>The Item in a Dictionary Member MUST NOT be a Parameters (0x2).</t>

</section>
<section anchor="item-field-values"><name>Item Field Values</name>

<t>Item values (type=0x3) have a payload consisting of Binary Item Types, as described in <xref target="types"/>.</t>

<figure><artwork><![CDATA[
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Item (..)
  [Parameters (..)]
}
]]></artwork></figure>

<t>An Item Field Value's fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the Item (including Parameters, if present), encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 5-bit prefix</t>
  <t>Item: An Item (<xref target="types"/>)</t>
  <t>Parameters: Optional Parameters (<xref target="parameter"/>)</t>
</list></t>

<t>The Item in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>

</section>
<section anchor="literal"><name>Binary Literal Field Values</name>

<t>Binary Literal values (type=0x4) are the string value of a field; they are used to carry field values that are not Binary Structured Fields, and may not be Structured Fields at all. As such, their semantics are that of String Literal Representations in <xref section="5.2" sectionFormat="of" target="RFC7541"/>.</t>

<figure><artwork><![CDATA[
Binary Literal Field Value {
  Top Level Type (3) = 4,
  Length (5..),
  Payload (..)
}
]]></artwork></figure>

<t>A Binary Literal Field Value's fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the string literal, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 5-bit prefix</t>
  <t>Payload: The raw octets of the field value</t>
</list></t>

</section>
</section>
<section anchor="types"><name>Binary Data Types</name>

<t>Every data type starts with a 5-bit type field that identifies the format of its payload.</t>

<figure><artwork><![CDATA[
Binary Data Type {
  Type (5)
}
]]></artwork></figure>

<t>Some data types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>

<section anchor="inner-list"><name>Inner Lists</name>

<t>The Inner List data type (type=0x1) has a payload in the format:</t>

<figure><artwork><![CDATA[
Inner List {
  Type (5) = 1,
  Length (3..),
  Item (..) ...
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the members, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 3-bit prefix</t>
  <t>Item(s): Length octets containing the Item(s) in the List</t>
</list></t>

<t>An Item in an Inner List MUST NOT be an Inner List (0x1).</t>

<t>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<xref target="parameter"/>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</t>

</section>
<section anchor="parameter"><name>Parameters</name>

<t>The Parameters data type (type=0x2) has a payload in the format:</t>

<figure><artwork><![CDATA[
Parameters {
  Type (5) = 2,
  Length (3..),
  Parameter (..) ...
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the payload, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 3-bit prefix</t>
  <t>Parameter(s): Length octets</t>
</list></t>

<t>Each Parameter conveys a key and a value:</t>

<figure><artwork><![CDATA[
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Binary Data Type (..)
}
]]></artwork></figure>

<t>A parameter's fields are:</t>

<t><list style="symbols">
  <t>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 8-bit prefix</t>
  <t>Parameter Name: Parameter Name Length octets of the parameter-name</t>
  <t>Binary Data Type: The parameter value, a Binary Data Type</t>
</list></t>

<t>The Binary Data Type in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>

<t>Parameters are always associated with the Binary Data Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Binary Data Type in a container, and MUST NOT follow another Parameters.</t>

</section>
<section anchor="integers"><name>Integers</name>

<t>The Integer data type (type=0x3) has a payload in the format:</t>

<figure><artwork><![CDATA[
Integer {
  Type (5) = 3,
  Sign (1),
  Payload (2..)
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Sign: sign bit; 0 is negative, 1 is positive</t>
  <t>Payload: The integer, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 2-bit prefix</t>
</list></t>

</section>
<section anchor="floats"><name>Floats</name>

<t>The Float data type (type=0x4) have a payload in the format:</t>

<figure><artwork><![CDATA[
Float {
  Type (5) = 4,
  Sign (1),
  Integer (2..),
  Fractional (8..)
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Sign: sign bit; 0 is negative, 1 is positive</t>
  <t>Integer: The integer component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 2-bit prefix.</t>
  <t>Fractional: The fractional component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 8-bit prefix.</t>
</list></t>

</section>
<section anchor="strings"><name>Strings</name>

<t>The String data type (type=0x5) has a payload in the format:</t>

<figure><artwork><![CDATA[
String {
  Type (5) = 5,
  Length (3..),
  Payload (..)
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the string, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 3-bit prefix.</t>
  <t>Payload: Length octets, ASCII-encoded.</t>
</list></t>

</section>
<section anchor="token"><name>Tokens</name>

<t>The Token data type (type=0x6) has a payload in the format:</t>

<figure><artwork><![CDATA[
Token {
  Type (5) = 6,
  Length (3..),
  Payload (..)
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the token, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 3-bit prefix.</t>
  <t>Payload: Length octets, ASCII-encoded.</t>
</list></t>

</section>
<section anchor="byte-sequences"><name>Byte Sequences</name>

<t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>

<figure><artwork><![CDATA[
Byte Sequence {
  Type (5) = 7,
  Length (3..),
  Payload (..)
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the byte sequence, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 3-bit prefix.</t>
  <t>Payload: Length octets.</t>
</list></t>

</section>
<section anchor="booleans"><name>Booleans</name>

<t>The Boolean data type (type=0x8) has a payload of two bits:</t>

<figure><artwork><![CDATA[
Boolean {
  Type (5) = 8,
  Payload (1),
  Padding (2) = 0
}
]]></artwork></figure>

<t>If Payload is 0, the value is False; if Payload is 1, the value is True.</t>

</section>
</section>
</section>
<section anchor="negotiate"><name>Using Binary Structured Fields in HTTP/2</name>

<t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields (or compatible with them; see <xref target="backport"/>) as binary data, rather than strings.</t>

<t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting"/>, and convey Binary Structured Fields in streams whose HEADERS frame uses the flag defined in <xref target="flag"/>.</t>

<section anchor="setting"><name>The SETTINGS_BINARY_STRUCTURED_FIELDS Setting</name>

<t>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS with a non-zero value from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the Binary Item Types defined in <xref target="fields"/>.</t>
  <t>The peer will process the BINARY_STRUCTRED HEADERS flag as defined in <xref target="flag"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Fields data types defined in <xref target="RFC8941"/>).</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased"/>) into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0, whereas a value of 1 indicates that this specification is supported with no further extensions. Future specifications might use values greater than one to indicate support for extensions.</t>

</section>
<section anchor="flag"><name>The BINARY_STRUCTRED HEADERS Flag</name>

<t>When a peer has indicated that it supports this specification as per <xref target="setting"/>, a sender can send the BINARY_STRUCTURED flag (0xTODO) on the HEADERS frame.</t>

<t>This flag indicates that the HEADERS frame containing it and subsequent CONTINUATION frames on the same stream use the Binary Representation defined in <xref target="binlit"/> instead of the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541"/> for all field values. Field names are still serialised as String Literal Representations.</t>

<t>In such frames, field values that are known to be Structured Fields and those that can be converted to Structured Fields (as per <xref target="backport"/>) MAY be sent using the applicable Binary Representation. However, any field value (including those defined as Structured Fields) can also be serialised as a Binary Literal (<xref target="literal"/>) to accommodate fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as a Structured Field for some other reason.</t>

<t>Binary Representations are stored in the HPACK <xref target="RFC7541"/> dynamic table, and their lengths are used for the purposes of maintaining dynamic table size (<xref section="4" sectionFormat="comma" target="RFC7541"/>).</t>

<t>Note that HEADERS frames with and without the BINARY_STRUCTURED flag MAY be mixed on the same connection, depending on the requirements of the sender.</t>

</section>
</section>
<section anchor="backport"><name>Using Binary Structured Fields with Existing Fields</name>

<t>Any field can potentially be parsed as a Structured Field according to the algorithms in <xref target="RFC8941"/> and serialised as a Binary Structured Field. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Fields by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct"><name>Directly Represented Fields</name>

<t>The following HTTP field names can have their values parsed as Structured Fields according to the algorithms in <xref target="RFC8941"/>, and thus can usually be serialised using the corresponding Binary Item Types.</t>

<t>When one of these fields' values cannot be represented using Structured Types in a Binary Representation, its value can instead be represented as a Binary Literal (<xref target="literal"/>).</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - Dictionary</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Connection - List</t>
  <t>Content-Encoding - List</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Expect-CT - Dictionary</t>
  <t>Forwarded - Dictionary</t>
  <t>Host - Item</t>
  <t>Keep-Alive - Dictionary</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
  <t>X-XSS-Protection - List</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Binary Literal (<xref target="literal"/>).</t>

</section>
<section anchor="aliased"><name>Aliased Fields</name>

<t>The following HTTP field names can have their values represented in Structured Fields by mapping them into its data types and then serialising the resulting Structured Field using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured Fields as:</t>

<figure><artwork><![CDATA[
SF-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Binary Literal (<xref target="literal"/>).</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Fields.</t>

<t><list style="symbols">
  <t>ISSUE: using separate names assures that the different syntax doesn't "leak" into normal fields, but it isn't strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn't understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></t>
</list></t>

<section anchor="urls"><name>URLs</name>

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SF-Content-Location</t>
  <t>Location - SF-Location</t>
  <t>Referer - SF-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SF-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates"><name>Dates</name>

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by parsing their payload according to <xref target="RFC7231"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SF-Date</t>
  <t>Expires - SF-Expires</t>
  <t>If-Modified-Since - SF-IMS</t>
  <t>If-Unmodified-Since - SF-IUS</t>
  <t>Last-Modified - SF-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SF-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags"><name>ETags</name>

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by representing the entity-tag as a string, and the weakness flag as a boolean "w" parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SF-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SF-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SF-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SF-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links"><name>Links</name>

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Fields by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SF-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SF-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies"><name>Cookies</name>

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Fields as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SF-Set-Cookie
Cookie: SF-Cookie</t>

<figure><artwork><![CDATA[
SF-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SF-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t><list style="symbols">
  <t>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></t>
  <t>ISSUE: dictionary keys cannot contain UC alpha. <eref target="https://github.com/mnot/I-D/issues/312">https://github.com/mnot/I-D/issues/312</eref></t>
  <t>ISSUE: explicitly allow non-string content. <eref target="https://github.com/mnot/I-D/issues/313">https://github.com/mnot/I-D/issues/313</eref></t>
</list></t>

</section>
</section>
</section>
<section anchor="iana-considerations"><name>IANA Considerations</name>

<t><list style="symbols">
  <t>ISSUE: todo</t>
</list></t>

</section>
<section anchor="security-considerations"><name>Security Considerations</name>

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of Binary Literals (<xref target="literal"/>). Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC7541' target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author fullname='R. Peon' initials='R.' surname='Peon'><organization/></author>
<author fullname='H. Ruellan' initials='H.' surname='Ruellan'><organization/></author>
<date month='May' year='2015'/>
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>


<reference anchor='I-D.ietf-quic-transport'>
   <front>
      <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
      <author fullname='Jana Iyengar'>
	 <organization>Fastly</organization>
      </author>
      <author fullname='Martin Thomson'>
	 <organization>Mozilla</organization>
      </author>
      <date day='14' month='January' year='2021'/>
      <abstract>
	 <t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration.  QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.
	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-quic-transport-34'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-quic-transport-34.txt' type='TXT'/>
</reference>



<reference anchor='RFC8941' target='https://www.rfc-editor.org/info/rfc8941'>
<front>
<title>Structured Field Values for HTTP</title>
<author fullname='M. Nottingham' initials='M.' surname='Nottingham'><organization/></author>
<author fullname='P-H. Kamp' initials='P-H.' surname='Kamp'><organization/></author>
<date month='February' year='2021'/>
<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as &quot;Structured Fields&quot;, &quot;Structured Headers&quot;, or &quot;Structured Trailers&quot;. It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>
</front>
<seriesInfo name='RFC' value='8941'/>
<seriesInfo name='DOI' value='10.17487/RFC8941'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference anchor='RFC7231' target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author fullname='R. Fielding' initials='R.' role='editor' surname='Fielding'><organization/></author>
<author fullname='J. Reschke' initials='J.' role='editor' surname='Reschke'><organization/></author>
<date month='June' year='2014'/>
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference anchor='RFC8288' target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author fullname='M. Nottingham' initials='M.' surname='Nottingham'><organization/></author>
<date month='October' year='2017'/>
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference anchor='RFC6265' target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author fullname='A. Barth' initials='A.' surname='Barth'><organization/></author>
<date month='April' year='2011'/>
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>



<section anchor="data-supporting-directly-represented-field-mappings"><name>Data Supporting Directly Represented Field Mappings</name>

<t><em>RFC EDITOR: please remove this section before publication</em></t>

<t>To help guide decisions about Directly Represented Fields, the HTTP response headers captured by the HTTP Archive <eref target="https://httparchive.org">https://httparchive.org</eref> in February 2020, representing more than 350,000,000 HTTP exchanges, were parsed as Structured Fields using the types listed in <xref target="direct"/>, with the indicated number of successful header instances, failures, and the resulting failure rate:</t>

<t><list style="symbols">
  <t>accept: 9,198 / 10 = 0.109%</t>
  <t>accept-encoding: 34,157 / 74 = 0.216%</t>
  <t>accept-language: 381,034 / 512 = 0.134%</t>
  <t>accept-patch: 5 / 0 = 0.000%</t>
  <t>accept-ranges: 197,746,643 / 3,960 = 0.002%</t>
  <t>access-control-allow-credentials: 16,684,916 / 7,438 = 0.045%</t>
  <t>access-control-allow-headers: 12,976,838 / 15,074 = 0.116%</t>
  <t>access-control-allow-methods: 15,466,748 / 28,203 = 0.182%</t>
  <t>access-control-allow-origin: 105,307,402 / 271,359 = 0.257%</t>
  <t>access-control-max-age: 5,284,663 / 7,754 = 0.147%</t>
  <t>access-control-request-headers: 39,328 / 624 = 1.562%</t>
  <t>access-control-request-method: 146,259 / 13,821 = 8.634%</t>
  <t>age: 71,281,684 / 172,398 = 0.241%</t>
  <t>allow: 351,704 / 1,886 = 0.533%</t>
  <t>alt-svc: 19,775,126 / 15,680,528 = 44.226%</t>
  <t>cache-control: 264,805,256 / 782,896 = 0.295%</t>
  <t>connection: 105,876,072 / 2,915 = 0.003%</t>
  <t>content-encoding: 139,799,523 / 379 = 0.000%</t>
  <t>content-language: 2,367,162 / 728 = 0.031%</t>
  <t>content-length: 296,624,718 / 787,843 = 0.265%</t>
  <t>content-type: 341,918,716 / 795,676 = 0.232%</t>
  <t>expect: 0 / 47 = 100.000%</t>
  <t>expect-ct: 26,569,605 / 29,114 = 0.109%</t>
  <t>forwarded: 119 / 35 = 22.727%</t>
  <t>host: 25,333 / 1,441 = 5.382%</t>
  <t>keep-alive: 43,061,546 / 796 = 0.002%</t>
  <t>origin: 24,335 / 1,539 = 5.948%</t>
  <t>pragma: 46,820,588 / 81,700 = 0.174%</t>
  <t>preference-applied: 57 / 0 = 0.000%</t>
  <t>retry-after: 605,844 / 6,195 = 1.012%</t>
  <t>strict-transport-security: 26,825,957 / 35,258,808 = 56.791%</t>
  <t>surrogate-control: 121,118 / 861 = 0.706%</t>
  <t>te: 1 / 0 = 0.000%</t>
  <t>trailer: 282 / 0 = 0.000%</t>
  <t>transfer-encoding: 13,952,661 / 0 = 0.000%</t>
  <t>vary: 150,787,199 / 41,313 = 0.027%</t>
  <t>x-content-type-options: 99,968,016 / 208,885 = 0.209%</t>
  <t>x-xss-protection: 79,871,948 / 362,979 = 0.452%</t>
</list></t>

<t>This data set focuses on response headers, although some request headers are present (because, the Web).</t>

<t><spanx style="verb">alt-svc</spanx> has a high failure rate because some currently-used ALPN tokens (e.g., <spanx style="verb">h3-Q43</spanx>) do not conform to key's syntax. Since the final version of HTTP/3 will use the <spanx style="verb">h3</spanx> token, this shouldn't be a long-term issue, although future tokens may again violate this assumption.</t>

<t><spanx style="verb">forwarded</spanx> has a high failure rate because many senders use the unquoted form for IP addresses, which makes integer parsing fail; e.g., <spanx style="verb">for=192.168.1.1</spanx>.</t>

<t><spanx style="verb">strict-transport-security</spanx> has a high failure rate because the <spanx style="verb">includeSubDomains</spanx> flag does not conform to the key syntax.</t>

<t>The top ten header fields in that data set that were not parsed as Directly Represented Fields are:</t>

<t><list style="symbols">
  <t>date: 354,652,447</t>
  <t>server: 311,275,961</t>
  <t>last-modified: 263,832,615</t>
  <t>expires: 199,967,042</t>
  <t>status: 192,423,509</t>
  <t>etag: 172,058,269</t>
  <t>timing-allow-origin: 64,407,586</t>
  <t>x-cache: 41,740,804</t>
  <t>p3p: 39,490,058</t>
  <t>x-frame-options: 34,037,985</t>
</list></t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAFFT/2AAA808aXPbypHf+Stmpdp60iuAIsCbXr+sno5YiSU7OnJUKmUP
wSGJFQgwACiJUTm/ffuYAQYgKZ9J5R02gbl6+p7uHriu28jDPFIj8WsYy3Qt
bvJ0FeSrVE3Em9vb9+I8VNFE/FFGK5U15HicqodRY5IEsVzAoEkqp7kbJ3ke
xrO5XLhjmsXNilncuZITlWZuq92YyBzGPJ8e3559agTwMEvS9Uhk+aTRCJfp
SMCoLPdbrWHLb8hUyZH4rYpVKqPGY5Lez9JktRw17tUaniYjcRHnKo1V7p4i
FI1Glst48kFGSQyrrAHcbCHT/MPfV0muspGIk8YyHIm/5kngCPgjjCcqzh2R
JWmeqmkGv9YL/SNPwwCagmSxlPrHAjpDUxhHYaz+1mjIVT5P0lFDuA0B/4Qx
LHHZFFcFLug1o+lSpvf1liSdyTj8h8zDJB6Jc5nl0ZoalglsJBrRbyFc8T6V
81TGxfMfL07od5Cs4hzxdwxIAxyFkl6rhQyjkVgAUf4X/2gChqhhlcLu53m+
zEZHR4+Pj03TetRoxEm6AEgeFC57fX7ie95Q/+x3Ox7+vHBPm6HKp+7fV2Hg
woJxtgTMjYB08bQc3mi4rivkGEEKgCi38zAT2VIF4TQMaLNioqaAwkxIwdwi
MpWGAH/GzcnUZkKb/wSsQ1zpCKTyTDyG+RymiYGR8pBHL1QwB7xmC+oc5plY
ZQqoQ+OO/GajcZHD6CwpwJgnj8AO1K2+Lq+4kPFaqKcwQ/KJKTfAJvO5StV4
LfbGMrhHXEDzHr5dYOvjXMUiWy2xAeaDfuMEoF0qEIamRhMQQH24wj/y5MM1
C0qj8TNgXZydXty+ux6JZaQkQJaqRfKgYHLEpgpoq2MF0CmxXI0jjdqfEd+w
2yxDbAFGc9oAjSJRFYHEcfB2FU+EzMX/GIaYASpX4yYw+hHyxRGQ+yiSYxVl
Rztl+pcmr7cAjgUIA5AQcZBMcxU7YhUTXNlcTQ712gCEvSKxn142TGjBnSsd
4VLXvALSd4bsA3vHLarPbwTFF1jhaDZ3lxLGvrylG6WYQ4CUDPpPmQhWaYqr
g2zmqwwZClsvzm7PBag1idx+r1JgzLxRgGI1kOg0QeaPQHcefbnapI0jqyzC
ySRSjcY+qr00mayIBwDYz4iKeH7+L+CnwbDjffoEsjWFSUFkMpWjoCGEIl8v
YUA+ByzG6tEwOHIK4A0gUyge6mmZqgy7qTCF4SAUeRhkTfFNAg6qE5i62C7h
8/mZV/70CbAI3KnnxMa6FHN3I/bq0ydA0vFkEuL0MorWDrQaoYRd1yQ9SOIH
tSnRMtuUf2eLGOePSSHFyP3LNFzgJmeJjHhvGwhBVoWFYd5VAANkmuG6INAp
kpl2K7MMTJLENQIQJ1gZ4CH7g9DkzIy5espXsEqqkBjAjjs1JhDmGBVFEk8K
2FD+QFYBFm3XQH+mqAtQeSNKUUxguiyERXBinASALxBbTIP8EMtxBINXuKhA
8yxQ++LsM7ANq0imjFhaDFmnop1JBe7vo1GUevITJEtM6zJiwdDjxECavcu7
m9s9h/8WV+/o9/XZH+4urs9O8ffNm+O3b4sfpsfNm3d3b0/LX/y+ASNP3l1e
nl2d8mB4K2qvLo//ssdcuPfu/e3Fu6vjt3ss86hJk2CF3oAh6xg5E1wR2CUp
o6wxUVmQhmN4gDG/nrwXXkfLIRpW4EgtlF6/Aw/IYrxYEkdr/QjkXgu5XCrA
I0wCXA0SuQzBMyDWaGTAzLFAC9TcYWQZhEzTFyUImQ7ZKCgwLSqQPj/faNPi
NdvIVTtsPskbaKJNl1Fbzed9LcoGND3tZxQD26pNMyxuSUPxaA1pqdS0GLIW
W6p0AeaPeFNmLDTJ0o3Ug4q2ehYPrC5Bw56GBCSA5Yi3oBqYJBc5m3OktQUA
kHuR4YTSYOG6KpMHoIHQVwRkHaIWCYM5CyDIbiQDRQxkbRhp8zbM0dmtT0X7
1Z4YbVevWNUCGesechVkGON8pTnRosg4qm3l+Zlea6Lub98P0lTvp1i/3gPn
/Zb9VWAxHNht+k3cUbFvJof2X8AakFI0/IMLb+UaNAwgOjsgzuYkwnNUglGU
PCKQbHjBkf3nP/+5fafiGdzh22Qp3hJX4TLioH3owNu3Kp6Bk3fQbTbh+RPN
AQ5nVtiYFF3kn2ujR2BEU3A6xmjo4FhCMqxlteRepJKh8bTk3SZMx8viNErE
q8VYpdgxCXLFlnPC1kdvgmZYynWUyIkDijxIJqS2UHgqFPBqBNDudhfclRzM
HpDtSQtfib4qvBVmGxF/7ZNwVc+VDXqlRfEAB75uPXmHYi4fkLIaVtRbmbbZ
JHnA30ou8LemEwkrK4titwaRC4V4KaQEPcemuNQvyflBUHEGBrqYwMaNlpRX
xWzFwDCGg6qLs74wvOxE0obcUUfGDuYSr4W3yWCCd3wAD6LZbBqGO95A8U8b
HPgNLIPIhJ2xbvw+tgEAEPKReAfeJR6xEo37g+wQVafG86HmmFI11/jGaqhx
j/8V3GPNohkCiHMmQWMzmVFx2/QEJ1CKiBDoaNbXriFyAx0Xx+tcFbzGs7gY
C6j3VxusixjYwbyuFnii8nac7GYffxv7bOx8Cy9tX+hHcpRteb+brza2NAK3
qmSyjWbA9wZCNS4Ql1dAtAJtA4023U5tB3VJxIe/vpcpNOaoIvDd3wCdW/DJ
82yi0lr0q/BpwfUtmBxUMWnNNqrgQcOwjbuPb04uLly9dCHlcIpg9FiS/bMo
cQR6YKlPATbinp+X5ol0AWKC5kGHeAvvmtMBegiyMhPqg6ZWJjRDVY3Qq5oC
aX9GgWyYHDqx1fzp0rNC4tdX3i2s7Rd1/Q4GY/6KNzb4Q0SVFw/jIFpNEAPl
+o4Ip0J3PfxhhuFfwTKbqKmyDLSjgWbreUAeCKiNXXykGcA4tZXoy/N+xK9L
b9n0q7FZ51AYHzRjL5k6sIkisr3SZ8G0dHsDmcKMU/sAUzgicZLvPJixD72Q
a+o13hbwxFmiCA7+4B2vgrlTD/hoaGWuT1O7/fpsw6GvkL9Z8bC3YHG3dHS2
Scd7LaUkIIXx2j39D5EKTTJN7B/A/HoXDEQqH2u61iJ5o3JaO8VAHnu+z/ss
MODCPChoKmJ8GLtMYa7KytSgT4dI1RCTIhx243MRBYdgeTybaE1YJV2xNBOM
yNQtSHCTgN2wwoygRHM4nsJUE9IjeOZ5BewVY7STxRFjk3Yzor31CgPM4TLE
LAx3C2dxwpID/MlSUKj4QowRHZbXrRVCKeUlcirHjsxS+zrUy5jQ50JrBnvT
dS+9/ZKXvuVY+A0cqA8i38J67U29C87QqGblNcGMJ2qcdI0VREFpdLSSLZHz
GfUK9LK0a6Jj6mUnIL6KpraBcUj/FMf+CbsC5fGzmE4TtWoPtCqdJKT/kKIY
jM2NdBmK60cbWtSblO+hlIvRs5SCYyAYaYVxsLb1vF+CwPxnNW7yn/8l/GdP
X+U/fxv/lVj51zDhdwQT2nX9pyHd5ER9JCv3wnF8RBVGiimIznqgjiTCUfm0
1aWvNRtHfkPHVc1LQdlNa7J1va/Eqp5B+9bf7dBXQRrtQEnV4lSBgEnqGOEt
Fd2YAk4ZFy06Mu9vIJQEuITk2xwy6xVFIaNHiYxR5lQIIfm29dnqLRZqgj2j
NaIrUIhnzORifktLvWMvbIPJhjnN8h2b0xqUsoPApMVQ1lrwLkHNYs1emrFc
zSglzFaLnraojPaXmSweXtMXdNK4AVsqDryqH+VbnL5FTeCYkchwJDDZK9HC
KEmsZlQH4AgPH5dJFuJj3bEJGZZvYWnfZmlG0zlMnGsk0e8tKOpsnOa24YhH
1zDUqWPIYJIwhC/OsdSBzyKkT34c1vRSFaxRQi2JyRh+H/4wdFzCzotMy718
1zqDapCYCMXHBU0pfXbYJFX3S7hZj66Rqrvd+G0eDH6M2WPv/3utXtOWjooO
roVTDBpvk3tFCZkcf2ifgl5uwWbvS7DJg2vI7P17kUmb+bfj8td1Dqyo/r6C
90pzZuXdFpT2vwSl1UlqqO3/e1GLwWjwmRmWfx2KC5wmSaSkyeLrpy14HNTx
iC7HY0JnPoNFPbiGv0EFX8Zu8YnxwMcerQKD06IjqNYWxTN0iAWez2WUqVd4
vrA6ebVOtykF3SnlfUdJ9J2J77JC5Xm/LE9pNP6EVSRl/RcedcgviDXmdYHJ
ltoRXQmAec9c3oMBmzxIcCdmOhUI5uo+Th4jNZmpakJUsw11oSmwny5X2AT8
IGG7Amti6ty4Sws8mqtKNc0h8o1O3yNNHZFK8l9gpVirRGSF97RRAFelOSVo
wfWZhFmAVS96n3rTXJggDebg+E8x1kpaWL8s0sBcwvMSHTi9k4lHKjV6c3Z8
enZ9g+ZtQXE0Hd6IZG0hfFOkwslOnd3eXlz99ubDrxdXx9d/+XBze313cnt3
fXb64fzi7O3pDUg5A/y8b6DEaiTeN6Xh9T4xG74bYsBVgBTgmrkdSHG+ABzw
iW/fnb471BVz4QNO9PlhppYyid1/qDTR7D9NkwVKqMIsGGemdbARJNRrsu+P
jXqT2dacVq12w9R5NRu+NcNjGEWgY5JAl5mJCqgAaUlEpJqsT6oJ124KkjYJ
x/zHWCf5MHS/WqDznAAweHSPwnv1iHxZih4ICqlGwnNeAYtKXyheQOWd4Ikl
VZYCCQqn5SCgJhOODiySQw1hzpOtKNaFxcriQDVnTedra7vseNqOohigfqeO
22LL5W6wrEgrCjMR4PU4CmVm6YbnZ8lvUPpp7xx0Q17RLbRDqqEDlQYEBPLr
0gCYV66ivAxrf54VWVE/4sGL7EMx1Kvx4LZau1KxmGNfnIjpKiUdBTgG14lL
2865dK0yOhOLcDbPqdpQB9ZnAERu1FvCxZAGiopoW3OX2mMnD58jDz/vE9dq
+6DFDG2iWcAEZXNbvjbLC40ht7WkjqmS5cCfmyKFKGdZMirDhOAqrG3qy6jn
Bv7rqtUKFwLUVMe5GrPvkYuTd1dA+rtjrKgzcqOXzHCwllbEvqVGXioXMjVW
WH+fqzJ2920VRxXvh4haCIiJMOsUQkywUywyR9myIpJcR/pCXgRr0GPKrmgc
ODtSOWix450mm0OSSaZDGLoyiiwj8T6M22LnC16xLfrl8V9wLDmMZZmgXC6x
sBz9ga2UaIo3yaN64LhGJR1lJwoZREu7bAB1SLBTxfVY1TAp6xkcUEYmtQaA
wx7Jai4SvFtS8XlMjPallR3qASCHk22NVL2muRxFiJgaLDQVt2lOMvYEFOuc
HbBYA75Rj4b8lGE6hOM9qNwAiS+W02V5kqrigPHm/fHJ7+1aQDFZAyOGAbiG
QCVHswSqZq5OycqsoSnFW67SZZJxbQrWCRphrcwksvAfFDzXK4HboYWkQ6al
gXcWGDc1K8heRMyaN1nlL2kdzXWL8ElNKmqgdIwdIN9SY173SEGXhCmRoAhS
sqprfomHTgCemdLvol61kAZMZhheRrZcwk5jcOOjaI3AYu222kVgZMWUmZ7r
tWU0S1JYcJHV7TNrxu2sXp/XkjOqLQKwgOPw4pJIlnm4wL0EBKCpLCcnRSsE
9bREs/RQ1glrUlqZPltu2EXJVjQhKKlAGUU5AbQHuXHBN1XPAsuVJ+wgbCJ+
vDY+Lco6OA0ayahJef7CydD285TWiyzJsCuMNTT1+kO68zC1dDQCR6E/O1Fo
0XGLYv1yMhpUrHgdg7aqGrMLr1PYyDJhht7wkpvaEaB6JeLs4hz3kwGciY8r
2BVpvIS1Ffa6Kfy8Vb04lM9lZY2QG/M53qhcfFkDNzEkcQxMssyFy9lA8+ye
aWd6o+GtjGcrPMLWG97LHIxi/e013/epvM4y9yTBizCRe4ykd09g1yyo2BNx
uqvnG75Z85n5LhUw+ORzvd6l4QyQvGvBS/nkHtM+t7dfo1+U5Z8FyfRjoKzp
KnNTNqGc4u37K+spyt2bh0DYZe769R3yaDHLiQzmyixc735SRiyKmbErIH4L
tU3LJrmLFg4flYvr9xTqKd6egQYL8vqze3JbB+88SR9lOqHtVBre4AW1Yvzv
lVoC/UAl1vvVyfk+lbOFrPd6n6op2O+tbzHC5h6j47QJxbXK07V7PM1pMIm9
OMDwSgDqSaJMAwGxyulmlabJDByaXXS4PStxeZvKMKIZyxdwulPpFor8EeW4
ePqza+Pb5XoqS3r+7P755sZ9n4IFrNDcsv50YSWnU16US5cvHPGVE/KlrR3b
57JXoFXsNq2HyqODpIuqLjl1ZJBixR4tGrSQ3KfS0SWDUwUAPa2v8CO1wamd
e5/3jUX6RiNja1Jgq602EY1mYbJpJ6iYrQO+9uniYkPGmMDUcK6u6X12RCxD
i1ekKblkwQvbPacDq0RnlsMPp4hq2hdfgChcoDQN6cZOQZDKbRZdAFUpWJaC
Lnrrqlq6832zAovT6omr5EF4w2FHtAajznDU7ovfXt6Woe4i5EqlumoKJ1ws
+InWG0YpLrJhZQycWEAUPIiRK9zZXRw+CbVMAOSDVmtE/4m72xN0KD3xOxmv
kC+8Yb8F/lUYgymPlFyaeQ4xirLKGEkaY0KO8TLuY7KKNiwm0PkA4yIcIT3c
5l6Y4PbNucvY6Q86rb7v9fu6rEB7qRPj/9jzT/XZREebEAsxaryyalC7V8Wl
n6/yGMjhy7Lpim5R/jAfodQYlUovDkmbI1asnnJ3nizLSi8rVJZV3CHKIbDT
61j+1faL4JXTvnVp9NDcoC4mWDRhBxwkczbqzWoxQDwxiCIUtortQJiZeMoG
qazizzLJcXod6wEpTIw2y1YL7FhkXbU/rouVtHYJUdcs5TgE9K7NLQXLkdYX
osmUWMGa2rWssj9XzTzKNQIFusgi+TYvnty9i5ubu7ORxlqmsPQDqKsjIllG
93kLok7CKZlFoPwa1PsTnZjjn3KxB1J2v8cqjz4/EBW8PV5RyCukfvwtBpCC
IrCIvF89hmem4kMbBZs47HQHutyLrvPOOCaO1Y+JScjYJMiSaf5Y1LkagK2w
LdKh+fKVc76Df9Ru9X/hrNjd9dusbkdsE3KwlGFqVaqE6Q6aZbqUwY4W6RNY
TRHtPASD3aFidtiQ5k1YzWThjFInWheeWqJjja4AtVV/i2nJSger4ZrcopTf
64ea/ZFVlWkGl2qyeCP2DM71YEL6NEn2WHXevnt3OuIPH4Aq1Mkohw5UFKJF
aVlKQHCmZguqbEBZJMd5rPJcF1eY28omr0uB4t/oq0goT/9BdLSO/DYN7SMs
H1j7fpsOrCaS0296+C+fYDcuHLFzsdPUGiPLJrdqas++3dQix5EjQsyCv9jd
D1M6/8E7/YBaaOpegnsL+Jy4NyEm2anDxeUNN97Fi23Nd9j8VuJhSjdrjr18
mSn1wiVPmhfC6/a9Ya/rd1rMg8glZ7dy9p/EJRv0xZ/52s05kSaLUhbtbYpH
UM4xJuJMrk2Ksc7F7z3uWeV+KCa5Ttbg93vUthSBtRoYMJybcu4tVLurOFO5
s6UbgJRoLYTo1PSHX9sJ9ashFPSwqIRPYk+OA/AC9l6Jx9e/8UxhgHsFegHO
6LlxZo3e0LU9jEbrSg+5fWwCK4OZs64+w0GVMSWEMK4OoCP2ZvPw/+4jrdX0
rdn43rAU0tUtPD6uw47vq567DlP5g8GnTz+CY+6uL7T6RmHaYJoIAHCJLSgd
Zdcy/kzQjUjK4MdnlD92LRU/Ddw7ouv2e3gHIHq9FyTLdYppOngh42CepK/3
9ksbgMg6SZL7UO1GF7cT4Dcqd/Wj9i0Zcz2/1/16zBFeqFyVJHtp1aWSp2Vf
dcRQICrjBxWtOVdb/RwC8mRE39bhUG1AN0yeKNZWiJbRjqVEhoU3VBzPMOsT
5vqTLnz/QtLXPuQhKGI8ReKpJiAsuNpqclKm+ABFiSZTgUGdUY2ZS95RuAg1
fjRC6aIsrVOtEsFT2iIMkojyH+XUxCPlY8N6q98YxrDHRDKevVaxe3fjGHS8
3vuTmsCJcyh+t4qF3/I94bVG3mDkdfDEudcoZoTJL05ft71JZzLsKTiHSTnp
+I41KXNV4faqJ8yKheiRGm/T0AB9icJa/uYL/cPBL+Xck/JK4z1Wtuujm6HZ
3QlQdjmXX+h6ev4vW8FmfweFTrNHwO7cl07b/oUSLRfHV8foH5IbKfV3W4r1
8mSSYC9wN1YpaPWNnsdU84I5DPxgFHvqEs9dYO4oimCFLrZ86YIiJGPmVMpr
mTwNp9nMqsaOKfMpH5nn9EGmjDCShNVTCpww0BF8VARRkm0uXabYgJEnEfvJ
eIsdeD+cseDSwQPvjIfZPX0uR9eKBjmZVIDeeG0IK5WFlSqQVhjv0i9lYKjy
DTRcYQ/slFySp/Cg9qwrqvpQntVO5XZlez2rCUhPZ6TotW/H9tjsoAh3FXgO
6YNC5rtmePwiHqFK+BsO++F+d6d0xCUHwr77+2cJmMFoKWYrYDZQSkGYMd3G
mI18IaXELghFwDhHA6vqj3DhkZupoO/sU6/jNJgjcxZCg39Lfolf+voFFeG5
Gqfk9IIOajlVq7rg62uAy3a35bRa9D/PDVqev3IGXIuO1UvpqjL8wQFDHQKo
pewKNilLSyx3voj6GB8CYz0SxcERUxlGeKYvncMy8qjbULljwM/FgweYp5EY
Ot5wII5A62IxZtNrDf+7aHVNldVItDsOuM/Qr9+hfr7Xs/pFOnEA/Qae02p3
oGPX83nGdsfquSSfSnShAy8ImLSaU8LlCE8eTr/Tc3qdNvRsO8Oe6e2b3lnm
BjrrQnrSDcrEEkwAYwcdZ+j1EGan0x7w+E5353jNQzDWd4b9njNoE166Tkvv
2Sv3vDF4wVkoPGQ4nV4PgMfB/sDxW20ePNgNeULZDBjb6jrtFkDb8nFw33Pa
3SGju9vfMnohn1zCetfxYbO9Xps22+9qeDvbBqU6RVVstz102j5C2/NxnNfs
9raBasbxTgFYII8P4AGK2s4A7PZrMWj2NLERKADfB24AMmCfvu+0h0wEv+NR
J9w7LN/1nH6L+jiDQY96dNtt7pG72UOA7OD0+13H83tMkd6g5XR9nK3Tafo+
kSWgfJiGdiT8XscZAD79LnHAwHcGQ57cHxIPlLULjPgBkLzVJ8QD23Q1u7V1
V4qilOLgAdL6wyEAQfzZH9q8bLqXUgF77/Udr4ez933Nim2v0llXi/tD4Fy/
4/S9AcHddwYd5iBwc+0BOV3panc8gHYA3WmbQ8BNX2+zTVRUlIMbgbQdiU4f
6dsqAOU2F5v9ntPtDZ1eCyXTB6XgdWx9MDUJO9i6hzRvI4J8v9n3icfAAuMk
wL7tNlGy00GG6DbbzPb3mMmTmMkbiU7bafU8p9thiHu2YBtJAAS0212aqdse
0kzDzgB7LCnTB7OAgIKi7g4QTQNkIa3A+h3uViT5JCf5QEr6da2TUmpLYmpr
JHrIBB1kxB7oxC6JQssjsNiilt9Vc405JcQNYN9DmryN/DYAvkMSd3vN/pBo
nBVpwoI9Pd8DHBPsPY9A6reIjTHN4NXhzDl1CKsN/C1tnEW0uRPg8UEfbEz0
IPE7tB5YMeQsb4ikBA4CV5F7MTWfXJvJ3ITzjWArhqCIB06LeM1vwUYHLCc+
c8mT+wQKY1nkIUEHDEGugENJG7Z7qFhZVDpdQCyXuZCnhFfJp0lA9d7gMdQN
O/pQWKY0m3NhllZGhd3Hc425SHEwVoFcZTpd9ic1xnDVR61LPuqbDHM4llaM
otCjeH79EdFo7VJNFqXoc77NoyuBP87b7h867Y+HJu4PKOOcQ4JHgp8yHUZv
Cg5q8d1DvK0FHlumC4ap9LhtKnm4E0z80dyxYS9qjukrDGzT11LQl3TxmM1f
j7Uwoz/xqOHEj0fIGZ5GHsIkkrn2yTDuvyCCIlYKuf48XqiiySSFDLCrmD7a
rJMp6CRfvMfvUKaFJ48JyIW8pxoXDk4WLjWs8kpobMLQ197Qb3q9AQY7PyJw
O6Xu88ASIrm0Ud2sxqcJVtBlH/U1AlMKaJEMB+DlZE00/aXCZCnwyGOHa/QX
Zc3dReRbrsZSuoyx9ABfKoviS0IuJ2BBb4D1BontdPqoLlT6gMLe9sCCgtkb
9jx4G2Eo1ERKUe+A1W2DkHtd1uQ6xkky2ndaHZ/0Fn4DF9/C3H7b6baG2DnH
UBta5BYoK7+H77A6Dfiq6o+ACYVzNujYHisFtLAj1Bf9TguUXAf1bHtJHkRn
2MLZqB9VGJZaA1zHVrvvDAdduprT+H+UC9EZy1wAAA==

-->

</rfc>

