<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-nottingham-binary-structured-headers-03" category="std" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.9.1 -->
  <front>
    <title>Binary Structured HTTP Field Values</title>
    <seriesInfo name="Internet-Draft" value="draft-nottingham-binary-structured-headers-03"/>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <postal>
          <postalLine>Prahran</postalLine>
          <postalLine>VIC</postalLine>
          <postalLine>Australia</postalLine>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <date/>
    <area>General</area>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</t>
      <t>It also defines how to use Structured Fields for many existing fields -- thereby "backporting" them -- when supported by both peers.</t>
    </abstract>
    <note>
      <name>Note to Readers</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>
      <t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>
      <t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>
      <t>See also the draft's current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>
    </note>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Structured Field Values for HTTP <xref target="RFC8941" format="default"/> offers a set of data types that new fields can use to express their semantics in a familiar textual syntax. This specification defines an alternative, binary serialisation of those structures in <xref target="fields" format="default"/>, and specifies its use in HTTP/2 in <xref target="negotiate" format="default"/>.</t>
      <t>Additionally, <xref target="backport" format="default"/> defines how to convey existing fields as Structured Fields, when supported by two peers.</t>
      <t>The primary goal is to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</t>
      <section anchor="notational-conventions" numbered="true" toc="default">
        <name>Notational Conventions</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when, and only when, they appear in all capitals, as
shown here.</t>
        <t>This specification describes formats using the convention described in <xref section="1.3" sectionFormat="of" target="I-D.ietf-quic-transport" format="default"/>.</t>
      </section>
    </section>
    <section anchor="fields" numbered="true" toc="default">
      <name>Binary Structured Fields</name>
      <t>This section defines a binary serialisation for the Structured Field Types defined in <xref target="RFC8941" format="default"/>.</t>
      <t>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Representation (<xref target="binlit" format="default"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541" format="default"/>.</t>
      <t>Binary representations of the remaining structured field types are defined in <xref target="types" format="default"/>.</t>
      <section anchor="binlit" numbered="true" toc="default">
        <name>Binary Representations</name>
        <t>Binary Representations are a replacement for the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/>, and can be used to serialise any field, including but not limited to those defined as Structured Fields.</t>
        <t>All Binary Representations share the following header:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Representation {
  Top Level Type (3),
  Length (5..),
}
]]></artwork>
        <t>Its fields are:</t>
        <ul spacing="normal">
          <li>Top Level Type: Three bits indicating the top-level type of the field value.</li>
          <li>Length: The number of octets used to represent the payload, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 5-bit prefix.</li>
        </ul>
        <t>The following top-level types are defined:</t>
        <section anchor="literal" numbered="true" toc="default">
          <name>Binary Literal Field Values</name>
          <t>Binary Literal field values (type=0x0) carry the string value of a field; they are used to carry field values that are not structured using the data types defined in <xref section="3" sectionFormat="of" target="RFC8941" format="default"/>. This might be because the field is not recognised as a Structured Field, or it might be because a field that is understood to be a Structured Field cannot be parsed successfully as one.</t>
          <t>A binary literal field value's payload is the raw octets of the field value. As such, they are functionally equivalent to String Literal Representations in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/>.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Literal Field Value {
  Top Level Type (3) = 0,
  Length (5..),
  Payload (..)
}
]]></artwork>
        </section>
        <section anchor="list-field-values" numbered="true" toc="default">
          <name>List Field Values</name>
          <t>Structured fields whose values are known to be a List as per <xref section="3.1" sectionFormat="of" target="RFC8941" format="default"/> can be conveyed as a binary representation with a top level type of 0x1. They have a payload consisting of one or more Binary Data Types (<xref target="types" format="default"/>) representing the members of the list.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Binary Data Type (..) ...
}
]]></artwork>
        </section>
        <section anchor="dictionary-field-values" numbered="true" toc="default">
          <name>Dictionary Field Values</name>
          <t>Structured fields whose values are known to be a Dictionary as per <xref section="3.2" sectionFormat="of" target="RFC8941" format="default"/> can be conveyed in a binary representation with a top level type of 0x2. They have a payload consisting of one or more Dictionary Members.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
]]></artwork>
          <t>Each Dictionary member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Data Type(s) representing the member-value.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Binary Data Type (..),
  [Parameters (..)]
}

]]></artwork>
          <t>The Binary Data Type in a Dictionary Member MUST NOT be a Parameters (0x2).</t>
        </section>
        <section anchor="item-field-values" numbered="true" toc="default">
          <name>Item Field Values</name>
          <t>Structured field values that are known to be an Item as per <xref section="3.3" sectionFormat="of" target="RFC8941" format="default"/> can be conveyed in a binary representation with a top level type of 0x3. They have a payload consisting of a single Binary Data Type (<xref target="types" format="default"/>), with optional parameters (<xref target="parameter" format="default"/>).</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Binary Data Type (..),
  [Parameters (..)]
}
]]></artwork>
          <t>The Binary Data Type in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
        </section>
      </section>
      <section anchor="types" numbered="true" toc="default">
        <name>Binary Data Types</name>
        <t>Binary data types are discrete values that are composed into binary representations (<xref target="binlit" format="default"/>) to represent the structured field values.</t>
        <t>Every binary data type starts with a 4-bit type field that identifies the format of its payload.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Data Type {
  Type (4)
}
]]></artwork>
        <t>Some data types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>
        <section anchor="inner-list" numbered="true" toc="default">
          <name>Inner Lists</name>
          <t>The Inner List data type (type=0x1) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Inner List {
  Type (4) = 1,
  Length (4..),
  Binary Data Type (..) ...
}
]]></artwork>
          <t>A Binary Data Type in an Inner List MUST NOT be an Inner List (0x1).</t>
          <t>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<xref target="parameter" format="default"/>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</t>
        </section>
        <section anchor="parameter" numbered="true" toc="default">
          <name>Parameters</name>
          <t>The Parameters data type (type=0x2) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameters {
  Type (4) = 2,
  Length (4..),
  Parameter (..) ...
}
]]></artwork>
          <t>Each Parameter conveys a key and a value:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Binary Data Type (..)
}
]]></artwork>
          <t>A parameter's fields are:</t>
          <ul spacing="normal">
            <li>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 8-bit prefix</li>
            <li>Parameter Name: Parameter Name Length octets of the parameter-name</li>
            <li>Binary Data Type: The parameter value, a Binary Data Type</li>
          </ul>
          <t>The Binary Data Type in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
          <t>Parameters are always associated with the Binary Data Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Binary Data Type in a Binary Representation, and MUST NOT follow another Parameters.</t>
        </section>
        <section anchor="integers" numbered="true" toc="default">
          <name>Integers</name>
          <t>The Integer data type (type=0x3) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Integer {
  Type (4) = 3,
  Sign (1),
  Payload (3..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Payload: The integer, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 2-bit prefix</li>
          </ul>
        </section>
        <section anchor="floats" numbered="true" toc="default">
          <name>Floats</name>
          <t>The Float data type (type=0x4) have a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Float {
  Type (4) = 4,
  Sign (1),
  Integer (3..),
  Fractional (8..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Integer: The integer component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 2-bit prefix.</li>
            <li>Fractional: The fractional component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 8-bit prefix.</li>
          </ul>
        </section>
        <section anchor="strings" numbered="true" toc="default">
          <name>Strings</name>
          <t>The String data type (type=0x5) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
String {
  Type (4) = 5,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>Its payload is Length octets long and ASCII-encoded.</t>
        </section>
        <section anchor="token" numbered="true" toc="default">
          <name>Tokens</name>
          <t>The Token data type (type=0x6) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Token {
  Type (4) = 6,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>Its payload is Length octets long and ASCII-encoded.</t>
        </section>
        <section anchor="byte-sequences" numbered="true" toc="default">
          <name>Byte Sequences</name>
          <t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Byte Sequence {
  Type (4) = 7,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>The payload is the raw octets of the byte sequence.</t>
        </section>
        <section anchor="booleans" numbered="true" toc="default">
          <name>Booleans</name>
          <t>The Boolean data type (type=0x8) has a payload of two bits:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Boolean {
  Type (4) = 8,
  Payload (1),
  Padding (3) = 0
}
]]></artwork>
          <t>If Payload is 0, the value is False; if Payload is 1, the value is True.</t>
        </section>
      </section>
    </section>
    <section anchor="negotiate" numbered="true" toc="default">
      <name>Using Binary Structured Fields in HTTP/2</name>
      <t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields (or compatible with them; see <xref target="backport" format="default"/>) as binary data, rather than strings.</t>
      <t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting" format="default"/>, and convey Binary Structured Fields in streams whose HEADERS frame uses the flag defined in <xref target="flag" format="default"/>.</t>
      <section anchor="setting" numbered="true" toc="default">
        <name>The SETTINGS_BINARY_STRUCTURED_FIELDS Setting</name>
        <t>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</t>
        <t>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS with a non-zero value from a peer indicates that:</t>
        <ol spacing="normal" type="1"><li>The peer supports the Binary Data Types defined in <xref target="fields" format="default"/>.</li>
          <li>The peer will process the BINARY_STRUCTRED HEADERS flag as defined in <xref target="flag" format="default"/>.</li>
          <li>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Fields data types defined in <xref target="RFC8941" format="default"/>).</li>
          <li>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased" format="default"/>) into their non-aliased forms as necessary.</li>
        </ol>
        <t>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0, whereas a value of 1 indicates that this specification is supported with no further extensions. Future specifications might use values greater than one to indicate support for extensions.</t>
      </section>
      <section anchor="flag" numbered="true" toc="default">
        <name>The BINARY_STRUCTRED HEADERS Flag</name>
        <t>When a peer has indicated that it supports this specification as per <xref target="setting" format="default"/>, a sender can send the BINARY_STRUCTURED flag (0xTODO) on the HEADERS frame.</t>
        <t>This flag indicates that the HEADERS frame containing it and subsequent CONTINUATION frames on the same stream use the Binary Representation defined in <xref target="binlit" format="default"/> instead of the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/> for all field values. Field names are still serialised as String Literal Representations.</t>
        <t>In such frames, field values that are known to be Structured Fields and those that can be converted to Structured Fields (as per <xref target="backport" format="default"/>) MAY be sent using the applicable Binary Representation. However, any field value (including those defined as Structured Fields) can also be serialised as a Binary Literal (<xref target="literal" format="default"/>) to accommodate fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as a Structured Field for some other reason.</t>
        <t>Binary Representations are stored in the HPACK <xref target="RFC7541" format="default"/> dynamic table, and their lengths are used for the purposes of maintaining dynamic table size (<xref section="4" sectionFormat="comma" target="RFC7541" format="default"/>).</t>
        <t>Note that HEADERS frames with and without the BINARY_STRUCTURED flag MAY be mixed on the same connection, depending on the requirements of the sender.</t>
      </section>
    </section>
    <section anchor="backport" numbered="true" toc="default">
      <name>Using Binary Structured Fields with Existing Fields</name>
      <t>Any field can potentially be parsed as a Structured Field according to the algorithms in <xref target="RFC8941" format="default"/> and serialised as a Binary Structured Field. However, many cannot, so optimistically parsing them can be expensive.</t>
      <t>This section identifies fields that will usually succeed in <xref target="direct" format="default"/>, and those that can be mapped into Structured Fields by using an alias field name in <xref target="aliased" format="default"/>.</t>
      <section anchor="direct" numbered="true" toc="default">
        <name>Directly Represented Fields</name>
        <t>The following HTTP field names can have their values parsed as Structured Fields according to the algorithms in <xref target="RFC8941" format="default"/>, and thus can usually be serialised using the corresponding Binary Data Types.</t>
        <t>When one of these fields' values cannot be represented using Structured Types in a Binary Representation, its value can instead be represented as a Binary Literal (<xref target="literal" format="default"/>).</t>
        <ul spacing="normal">
          <li>Accept - List</li>
          <li>Accept-Encoding - List</li>
          <li>Accept-Language - List</li>
          <li>Accept-Patch - List</li>
          <li>Accept-Ranges - List</li>
          <li>Access-Control-Allow-Credentials - Item</li>
          <li>Access-Control-Allow-Headers - List</li>
          <li>Access-Control-Allow-Methods - List</li>
          <li>Access-Control-Allow-Origin - Item</li>
          <li>Access-Control-Max-Age - Item</li>
          <li>Access-Control-Request-Headers - List</li>
          <li>Access-Control-Request-Method - Item</li>
          <li>Age - Item</li>
          <li>Allow - List</li>
          <li>ALPN - List</li>
          <li>Alt-Svc - Dictionary</li>
          <li>Alt-Used - Item</li>
          <li>Cache-Control - Dictionary</li>
          <li>Connection - List</li>
          <li>Content-Encoding - List</li>
          <li>Content-Language - List</li>
          <li>Content-Length - Item</li>
          <li>Content-Type - Item</li>
          <li>Expect - Item</li>
          <li>Expect-CT - Dictionary</li>
          <li>Forwarded - Dictionary</li>
          <li>Host - Item</li>
          <li>Keep-Alive - Dictionary</li>
          <li>Origin - Item</li>
          <li>Pragma - Dictionary</li>
          <li>Prefer - Dictionary</li>
          <li>Preference-Applied - Dictionary</li>
          <li>Retry-After - Item  (see caveat below)</li>
          <li>Surrogate-Control - Dictionary</li>
          <li>TE - List</li>
          <li>Trailer - List</li>
          <li>Transfer-Encoding - List</li>
          <li>Vary - List</li>
          <li>X-Content-Type-Options - Item</li>
          <li>X-XSS-Protection - List</li>
        </ul>
        <t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Binary Literal (<xref target="literal" format="default"/>).</t>
      </section>
      <section anchor="aliased" numbered="true" toc="default">
        <name>Aliased Fields</name>
        <t>The following HTTP field names can have their values represented in Structured Fields by mapping them into its data types and then serialising the resulting Structured Field using an alternative field name.</t>
        <t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork>
        <t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured Fields as:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Date: 784072177
]]></artwork>
        <t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Binary Literal (<xref target="literal" format="default"/>).</t>
        <t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate" format="default"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>
        <t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Fields.</t>
        <ul spacing="normal">
          <li>ISSUE: using separate names assures that the different syntax doesn't "leak" into normal fields, but it isn't strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn't understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></li>
        </ul>
        <section anchor="urls" numbered="true" toc="default">
          <name>URLs</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by considering their payload a string.</t>
          <ul spacing="normal">
            <li>Content-Location - SF-Content-Location</li>
            <li>Location - SF-Location</li>
            <li>Referer - SF-Referer</li>
          </ul>
          <t>For example, a (non-binary) Location:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Location: "https://example.com/foo"
]]></artwork>
          <t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>
        </section>
        <section anchor="dates" numbered="true" toc="default">
          <name>Dates</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by parsing their payload according to <xref target="RFC7231" format="default"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>
          <ul spacing="normal">
            <li>Date - SF-Date</li>
            <li>Expires - SF-Expires</li>
            <li>If-Modified-Since - SF-IMS</li>
            <li>If-Unmodified-Since - SF-IUS</li>
            <li>Last-Modified - SF-LM</li>
          </ul>
          <t>For example, a (non-binary) Expires:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Expires: 1571965240
]]></artwork>
        </section>
        <section anchor="etags" numbered="true" toc="default">
          <name>ETags</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by representing the entity-tag as a string, and the weakness flag as a boolean "w" parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>
          <ul spacing="normal">
            <li>ETag - SF-ETag</li>
          </ul>
          <t>For example, a (non-Binary) ETag:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-ETag: "abcdef"; w=?1
]]></artwork>
          <t>If-None-Match is a list of the structure described above.</t>
          <ul spacing="normal">
            <li>If-None-Match - SF-INM</li>
          </ul>
          <t>For example, a (non-binary) If-None-Match:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork>
        </section>
        <section anchor="links" numbered="true" toc="default">
          <name>Links</name>
          <t>The field-value of the Link header field <xref target="RFC8288" format="default"/> can be represented in Binary Structured Fields by representing the URI-Reference as a string, and link-param as parameters.</t>
          <ul spacing="normal">
            <li>Link: SF-Link</li>
          </ul>
          <t>For example, a (non-binary) Link:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork>
        </section>
        <section anchor="cookies" numbered="true" toc="default">
          <name>Cookies</name>
          <t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265" format="default"/> can be represented in Binary Structured Fields as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>
          <t>Set-Cookie: SF-Set-Cookie
Cookie: SF-Cookie</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SF-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork>
          <ul spacing="normal">
            <li>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></li>
            <li>ISSUE: dictionary keys cannot contain UC alpha. <eref target="https://github.com/mnot/I-D/issues/312">https://github.com/mnot/I-D/issues/312</eref></li>
            <li>ISSUE: explicitly allow non-string content. <eref target="https://github.com/mnot/I-D/issues/313">https://github.com/mnot/I-D/issues/313</eref></li>
          </ul>
        </section>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <ul spacing="normal">
        <li>ISSUE: todo</li>
      </ul>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>
      <t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of Binary Literals (<xref target="literal" format="default"/>). Therefore, implementation divergence from this strictness can have security impact.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author fullname="S. Bradner" initials="S." surname="Bradner">
            <organization/>
          </author>
          <date month="March" year="1997"/>
          <abstract>
            <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <seriesInfo name="DOI" value="10.17487/RFC2119"/>
      </reference>
      <reference anchor="RFC7541" target="https://www.rfc-editor.org/info/rfc7541">
        <front>
          <title>HPACK: Header Compression for HTTP/2</title>
          <author fullname="R. Peon" initials="R." surname="Peon">
            <organization/>
          </author>
          <author fullname="H. Ruellan" initials="H." surname="Ruellan">
            <organization/>
          </author>
          <date month="May" year="2015"/>
          <abstract>
            <t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7541"/>
        <seriesInfo name="DOI" value="10.17487/RFC7541"/>
      </reference>
      <reference anchor="I-D.ietf-quic-transport" target="https://www.ietf.org/archive/id/draft-ietf-quic-transport-34.txt">
        <front>
          <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
          <author fullname="Jana Iyengar">
            <organization>Fastly</organization>
          </author>
          <author fullname="Martin Thomson">
            <organization>Mozilla</organization>
          </author>
          <date day="14" month="January" year="2021"/>
          <abstract>
            <t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration.  QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.
            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-quic-transport-34"/>
      </reference>
      <reference anchor="RFC8941" target="https://www.rfc-editor.org/info/rfc8941">
        <front>
          <title>Structured Field Values for HTTP</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <author fullname="P-H. Kamp" initials="P-H." surname="Kamp">
            <organization/>
          </author>
          <date month="February" year="2021"/>
          <abstract>
            <t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8941"/>
        <seriesInfo name="DOI" value="10.17487/RFC8941"/>
      </reference>
      <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174">
        <front>
          <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
          <author fullname="B. Leiba" initials="B." surname="Leiba">
            <organization/>
          </author>
          <date month="May" year="2017"/>
          <abstract>
            <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="8174"/>
        <seriesInfo name="DOI" value="10.17487/RFC8174"/>
      </reference>
      <reference anchor="RFC7231" target="https://www.rfc-editor.org/info/rfc7231">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
          <author fullname="R. Fielding" initials="R." role="editor" surname="Fielding">
            <organization/>
          </author>
          <author fullname="J. Reschke" initials="J." role="editor" surname="Reschke">
            <organization/>
          </author>
          <date month="June" year="2014"/>
          <abstract>
            <t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7231"/>
        <seriesInfo name="DOI" value="10.17487/RFC7231"/>
      </reference>
      <reference anchor="RFC8288" target="https://www.rfc-editor.org/info/rfc8288">
        <front>
          <title>Web Linking</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <date month="October" year="2017"/>
          <abstract>
            <t>This specification defines a model for the relationships between resources on the Web ("links") and the type of those relationships ("link relation types").</t>
            <t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8288"/>
        <seriesInfo name="DOI" value="10.17487/RFC8288"/>
      </reference>
      <reference anchor="RFC6265" target="https://www.rfc-editor.org/info/rfc6265">
        <front>
          <title>HTTP State Management Mechanism</title>
          <author fullname="A. Barth" initials="A." surname="Barth">
            <organization/>
          </author>
          <date month="April" year="2011"/>
          <abstract>
            <t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="6265"/>
        <seriesInfo name="DOI" value="10.17487/RFC6265"/>
      </reference>
    </references>
    <section anchor="data-supporting-directly-represented-field-mappings" numbered="true" toc="default">
      <name>Data Supporting Directly Represented Field Mappings</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>To help guide decisions about Directly Represented Fields, the HTTP response headers captured by the HTTP Archive <eref target="https://httparchive.org">https://httparchive.org</eref> in February 2020, representing more than 350,000,000 HTTP exchanges, were parsed as Structured Fields using the types listed in <xref target="direct" format="default"/>, with the indicated number of successful header instances, failures, and the resulting failure rate:</t>
      <ul spacing="normal">
        <li>accept: 9,198 / 10 = 0.109%</li>
        <li>accept-encoding: 34,157 / 74 = 0.216%</li>
        <li>accept-language: 381,034 / 512 = 0.134%</li>
        <li>accept-patch: 5 / 0 = 0.000%</li>
        <li>accept-ranges: 197,746,643 / 3,960 = 0.002%</li>
        <li>access-control-allow-credentials: 16,684,916 / 7,438 = 0.045%</li>
        <li>access-control-allow-headers: 12,976,838 / 15,074 = 0.116%</li>
        <li>access-control-allow-methods: 15,466,748 / 28,203 = 0.182%</li>
        <li>access-control-allow-origin: 105,307,402 / 271,359 = 0.257%</li>
        <li>access-control-max-age: 5,284,663 / 7,754 = 0.147%</li>
        <li>access-control-request-headers: 39,328 / 624 = 1.562%</li>
        <li>access-control-request-method: 146,259 / 13,821 = 8.634%</li>
        <li>age: 71,281,684 / 172,398 = 0.241%</li>
        <li>allow: 351,704 / 1,886 = 0.533%</li>
        <li>alt-svc: 19,775,126 / 15,680,528 = 44.226%</li>
        <li>cache-control: 264,805,256 / 782,896 = 0.295%</li>
        <li>connection: 105,876,072 / 2,915 = 0.003%</li>
        <li>content-encoding: 139,799,523 / 379 = 0.000%</li>
        <li>content-language: 2,367,162 / 728 = 0.031%</li>
        <li>content-length: 296,624,718 / 787,843 = 0.265%</li>
        <li>content-type: 341,918,716 / 795,676 = 0.232%</li>
        <li>expect: 0 / 47 = 100.000%</li>
        <li>expect-ct: 26,569,605 / 29,114 = 0.109%</li>
        <li>forwarded: 119 / 35 = 22.727%</li>
        <li>host: 25,333 / 1,441 = 5.382%</li>
        <li>keep-alive: 43,061,546 / 796 = 0.002%</li>
        <li>origin: 24,335 / 1,539 = 5.948%</li>
        <li>pragma: 46,820,588 / 81,700 = 0.174%</li>
        <li>preference-applied: 57 / 0 = 0.000%</li>
        <li>retry-after: 605,844 / 6,195 = 1.012%</li>
        <li>strict-transport-security: 26,825,957 / 35,258,808 = 56.791%</li>
        <li>surrogate-control: 121,118 / 861 = 0.706%</li>
        <li>te: 1 / 0 = 0.000%</li>
        <li>trailer: 282 / 0 = 0.000%</li>
        <li>transfer-encoding: 13,952,661 / 0 = 0.000%</li>
        <li>vary: 150,787,199 / 41,313 = 0.027%</li>
        <li>x-content-type-options: 99,968,016 / 208,885 = 0.209%</li>
        <li>x-xss-protection: 79,871,948 / 362,979 = 0.452%</li>
      </ul>
      <t>This data set focuses on response headers, although some request headers are present (because, the Web).</t>
      <t><tt>alt-svc</tt> has a high failure rate because some currently-used ALPN tokens (e.g., <tt>h3-Q43</tt>) do not conform to key's syntax. Since the final version of HTTP/3 will use the <tt>h3</tt> token, this shouldn't be a long-term issue, although future tokens may again violate this assumption.</t>
      <t><tt>forwarded</tt> has a high failure rate because many senders use the unquoted form for IP addresses, which makes integer parsing fail; e.g., <tt>for=192.168.1.1</tt>.</t>
      <t><tt>strict-transport-security</tt> has a high failure rate because the <tt>includeSubDomains</tt> flag does not conform to the key syntax.</t>
      <t>The top ten header fields in that data set that were not parsed as Directly Represented Fields are:</t>
      <ul spacing="normal">
        <li>date: 354,652,447</li>
        <li>server: 311,275,961</li>
        <li>last-modified: 263,832,615</li>
        <li>expires: 199,967,042</li>
        <li>status: 192,423,509</li>
        <li>etag: 172,058,269</li>
        <li>timing-allow-origin: 64,407,586</li>
        <li>x-cache: 41,740,804</li>
        <li>p3p: 39,490,058</li>
        <li>x-frame-options: 34,037,985</li>
      </ul>
    </section>
  </back>
  <!-- ##markdown-source:
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
wHXsBANnNOzR1ZzW/wIABOLxsVgAAA==

-->

</rfc>
