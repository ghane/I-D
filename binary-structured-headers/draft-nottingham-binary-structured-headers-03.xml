<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.6 -->
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-nottingham-binary-structured-headers-03" category="std" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.10.0 -->
  <front>
    <title>Binary Structured HTTP Field Values</title>
    <seriesInfo name="Internet-Draft" value="draft-nottingham-binary-structured-headers-03"/>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization/>
      <address>
        <postal>
          <postalLine>Prahran</postalLine>
          <postalLine>VIC</postalLine>
          <postalLine>Australia</postalLine>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <date/>
    <area>General</area>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</t>
    </abstract>
    <note>
      <name>Note to Readers</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>
      <t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>
      <t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>
      <t>See also the draft's current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>
    </note>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Structured Field Values for HTTP <xref target="STRUCTURED-FIELDS" format="default"/> offers a set of data types that new fields can use to express their semantics in a familiar textual syntax. This specification defines an alternative, binary serialisation of those structures in <xref target="fields" format="default"/>, and specifies its use in HTTP/2 in <xref target="negotiate" format="default"/>.</t>
      <t>The primary goal is to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</t>
      <section anchor="notational-conventions" numbered="true" toc="default">
        <name>Notational Conventions</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when, and only when, they appear in all capitals, as
shown here.</t>
        <t>This specification describes formats using the convention described in <xref section="1.3" sectionFormat="of" target="QUIC" format="default"/>.</t>
      </section>
    </section>
    <section anchor="fields" numbered="true" toc="default">
      <name>Binary Structured Fields</name>
      <t>This section defines a binary serialisation for the Structured Field Types defined in <xref target="STRUCTURED-FIELDS" format="default"/>.</t>
      <t>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Representation (<xref target="binlit" format="default"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541" format="default"/>.</t>
      <t>Binary representations of the remaining structured field types are defined in <xref target="types" format="default"/>.</t>
      <section anchor="binlit" numbered="true" toc="default">
        <name>Binary Representations</name>
        <t>Binary Representations are a replacement for the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/>, and can be used to serialise any field, including but not limited to those defined as Structured Fields.</t>
        <t>All Binary Representations share the following header:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Representation {
  Top Level Type (3),
  Length (5..),
}
]]></artwork>
        <t>Its fields are:</t>
        <ul spacing="normal">
          <li>Top Level Type: Three bits indicating the top-level type of the field value.</li>
          <li>Length: The number of octets used to represent the entire field value (including the header), encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 5-bit prefix.</li>
        </ul>
        <t>The following top-level types are defined:</t>
        <section anchor="literal" numbered="true" toc="default">
          <name>Binary Literal Field Values</name>
          <t>Binary Literal field values (type=0x0) carry the string value of a field; they are used to carry field values that are not structured using the data types defined in <xref section="3" sectionFormat="of" target="STRUCTURED-FIELDS" format="default"/>. This might be because the field is not recognised as a Structured Field, or it might be because a field that is understood to be a Structured Field cannot be parsed successfully as one.</t>
          <t>A binary literal field value's payload is the raw octets of the field value. As such, they are functionally equivalent to String Literal Representations in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/>.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Literal Field Value {
  Top Level Type (3) = 0,
  Length (5..),
  Payload (..)
}
]]></artwork>
        </section>
        <section anchor="list-field-values" numbered="true" toc="default">
          <name>List Field Values</name>
          <t>Structured fields whose values are known to be a List as per <xref section="3.1" sectionFormat="of" target="STRUCTURED-FIELDS" format="default"/> can be conveyed as a binary representation with a top level type of 0x1. They have a payload consisting of one or more Binary Data Types (<xref target="types" format="default"/>) representing the members of the list.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Binary Data Type (..) ...
}
]]></artwork>
        </section>
        <section anchor="dictionary-field-values" numbered="true" toc="default">
          <name>Dictionary Field Values</name>
          <t>Structured fields whose values are known to be a Dictionary as per <xref section="3.2" sectionFormat="of" target="STRUCTURED-FIELDS" format="default"/> can be conveyed in a binary representation with a top level type of 0x2. They have a payload consisting of one or more Dictionary Members.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
]]></artwork>
          <t>Each Dictionary member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Data Type(s) representing the member-value.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Binary Data Type (..),
  [Parameters (..)]
}

]]></artwork>
          <t>The Binary Data Type in a Dictionary Member MUST NOT be a Parameters (0x2).</t>
        </section>
        <section anchor="item-field-values" numbered="true" toc="default">
          <name>Item Field Values</name>
          <t>Structured field values that are known to be an Item as per <xref section="3.3" sectionFormat="of" target="STRUCTURED-FIELDS" format="default"/> can be conveyed in a binary representation with a top level type of 0x3. They have a payload consisting of a single Binary Data Type (<xref target="types" format="default"/>), with optional parameters (<xref target="parameter" format="default"/>).</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Binary Data Type (..),
  [Parameters (..)]
}
]]></artwork>
          <t>The Binary Data Type in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
        </section>
      </section>
      <section anchor="types" numbered="true" toc="default">
        <name>Binary Data Types</name>
        <t>Binary data types are discrete values that are composed into binary representations (<xref target="binlit" format="default"/>) to represent the structured field values.</t>
        <t>Every binary data type starts with a 4-bit type field that identifies the format of its payload.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Data Type {
  Type (4)
}
]]></artwork>
        <t>Some data types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>
        <section anchor="inner-list" numbered="true" toc="default">
          <name>Inner Lists</name>
          <t>The Inner List data type (type=0x1) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Inner List {
  Type (4) = 1,
  Length (4..),
  Binary Data Type (..) ...
}
]]></artwork>
          <t>Length conveys the number of octets used to represent the inner list, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 4-bit prefix.</t>
          <t>A Binary Data Type in an Inner List MUST NOT be an Inner List (0x1).</t>
          <t>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<xref target="parameter" format="default"/>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</t>
        </section>
        <section anchor="parameter" numbered="true" toc="default">
          <name>Parameters</name>
          <t>The Parameters data type (type=0x2) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameters {
  Type (4) = 2,
  Length (4..),
  Parameter (..) ...
}
]]></artwork>
          <t>Length conveys the number of octets used to represent the parameters, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 4-bit prefix.</t>
          <t>Each Parameter conveys a key and a value:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Binary Data Type (..)
}
]]></artwork>
          <t>A parameter's fields are:</t>
          <ul spacing="normal">
            <li>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 8-bit prefix</li>
            <li>Parameter Name: Parameter Name Length octets of the parameter-name</li>
            <li>Binary Data Type: The parameter value, a Binary Data Type</li>
          </ul>
          <t>The Binary Data Type in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
          <t>Parameters are always associated with the Binary Data Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Binary Data Type in a Binary Representation, and MUST NOT follow another Parameters.</t>
        </section>
        <section anchor="integers" numbered="true" toc="default">
          <name>Integers</name>
          <t>The Integer data type (type=0x3) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Integer {
  Type (4) = 3,
  Sign (1),
  Payload (3..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Payload: The integer, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 2-bit prefix</li>
          </ul>
        </section>
        <section anchor="floats" numbered="true" toc="default">
          <name>Floats</name>
          <t>The Float data type (type=0x4) have a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Float {
  Type (4) = 4,
  Sign (1),
  Integer (3..),
  Fractional (8..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Integer: The integer component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 2-bit prefix.</li>
            <li>Fractional: The fractional component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 8-bit prefix.</li>
          </ul>
        </section>
        <section anchor="strings" numbered="true" toc="default">
          <name>Strings</name>
          <t>The String data type (type=0x5) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
String {
  Type (4) = 5,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>Its payload is Length octets long and ASCII-encoded.</t>
        </section>
        <section anchor="token" numbered="true" toc="default">
          <name>Tokens</name>
          <t>The Token data type (type=0x6) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Token {
  Type (4) = 6,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>Its payload is Length octets long and ASCII-encoded.</t>
        </section>
        <section anchor="byte-sequences" numbered="true" toc="default">
          <name>Byte Sequences</name>
          <t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Byte Sequence {
  Type (4) = 7,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>The payload is is Length octets long, containing the raw octets of the byte sequence.</t>
        </section>
        <section anchor="booleans" numbered="true" toc="default">
          <name>Booleans</name>
          <t>The Boolean data type (type=0x8) has a payload of two bits:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Boolean {
  Type (4) = 8,
  Payload (1),
  Padding (3) = 0
}
]]></artwork>
          <t>If Payload is 0, the value is False; if Payload is 1, the value is True.</t>
        </section>
      </section>
    </section>
    <section anchor="negotiate" numbered="true" toc="default">
      <name>Using Binary Structured Fields in HTTP/2</name>
      <t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields as binary data, rather than strings.</t>
      <t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting" format="default"/>, and convey Binary Structured Fields in streams whose HEADERS frame uses the flag defined in <xref target="flag" format="default"/>.</t>
      <section anchor="setting" numbered="true" toc="default">
        <name>The SETTINGS_BINARY_STRUCTURED_FIELDS Setting</name>
        <t>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</t>
        <t>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS with a non-zero value from a peer indicates that:</t>
        <ol spacing="normal" type="1"><li>The peer supports all of the Binary Data Types defined in <xref target="fields" format="default"/>.</li>
          <li>The peer will process the BINARY_STRUCTRED HEADERS flag as defined in <xref target="flag" format="default"/>.</li>
          <li>
            <t>When passing the message to a downstream consumer (whether on the network or not), the peer will:
            </t>
            <ol spacing="normal" type="1"><li>Transform all fields defined as Mapped Fields in Section 1.3 of <xref target="RETROFIT" format="default"/> into their unmapped forms, removing the mapped fields.</li>
              <li>Transform the message fields into the appropriate form for that peer (e.g., the textual representation of Structured Fields data types defined in <xref target="STRUCTURED-FIELDS" format="default"/>).</li>
            </ol>
          </li>
        </ol>
        <t>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0, whereas a value of 1 indicates that this specification is supported with no further extensions. Future specifications might use values greater than one to indicate support for extensions.</t>
      </section>
      <section anchor="flag" numbered="true" toc="default">
        <name>The BINARY_STRUCTRED HEADERS Flag</name>
        <t>When a peer has indicated that it supports this specification as per <xref target="setting" format="default"/>, a sender can send the BINARY_STRUCTURED flag (0xTODO) on the HEADERS frame.</t>
        <t>This flag indicates that the HEADERS frame containing it and subsequent CONTINUATION frames on the same stream use the Binary Representation defined in <xref target="binlit" format="default"/> instead of the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/> for all field values. Field names are still serialised as String Literal Representations.</t>
        <t>In such frames, field values that are known to be Structured Fields and those that can be converted to Structured Fields (as per <xref target="RETROFIT" format="default"/>) MAY be sent using the applicable Binary Representation. However, any field value (including those defined as Structured Fields) can also be serialised as a Binary Literal (<xref target="literal" format="default"/>) to accommodate fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as a Structured Field for some other reason.</t>
        <t>Binary Representations are stored in the HPACK <xref target="RFC7541" format="default"/> dynamic table, and their lengths are used for the purposes of maintaining dynamic table size (see <xref section="4" sectionFormat="comma" target="RFC7541" format="default"/>).</t>
        <t>Note that HEADERS frames with and without the BINARY_STRUCTURED flag MAY be mixed on the same connection, depending on the requirements of the sender.</t>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <ul spacing="normal">
        <li>ISSUE: todo</li>
      </ul>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>
      <t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of Binary Literals (<xref target="literal" format="default"/>). Therefore, implementation divergence from this strictness can have security impact.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author fullname="S. Bradner" initials="S." surname="Bradner">
            <organization/>
          </author>
          <date month="March" year="1997"/>
          <abstract>
            <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <seriesInfo name="DOI" value="10.17487/RFC2119"/>
      </reference>
      <reference anchor="RFC7541" target="https://www.rfc-editor.org/info/rfc7541">
        <front>
          <title>HPACK: Header Compression for HTTP/2</title>
          <author fullname="R. Peon" initials="R." surname="Peon">
            <organization/>
          </author>
          <author fullname="H. Ruellan" initials="H." surname="Ruellan">
            <organization/>
          </author>
          <date month="May" year="2015"/>
          <abstract>
            <t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7541"/>
        <seriesInfo name="DOI" value="10.17487/RFC7541"/>
      </reference>
      <reference anchor="STRUCTURED-FIELDS" target="https://www.rfc-editor.org/info/rfc8941">
        <front>
          <title>Structured Field Values for HTTP</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <author fullname="P-H. Kamp" initials="P-H." surname="Kamp">
            <organization/>
          </author>
          <date month="February" year="2021"/>
          <abstract>
            <t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8941"/>
        <seriesInfo name="DOI" value="10.17487/RFC8941"/>
      </reference>
      <reference anchor="QUIC" target="https://www.rfc-editor.org/info/rfc9001">
        <front>
          <title>Using TLS to Secure QUIC</title>
          <author fullname="M. Thomson" initials="M." role="editor" surname="Thomson">
            <organization/>
          </author>
          <author fullname="S. Turner" initials="S." role="editor" surname="Turner">
            <organization/>
          </author>
          <date month="May" year="2021"/>
          <abstract>
            <t>This document describes how Transport Layer Security (TLS) is used to secure QUIC.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="9001"/>
        <seriesInfo name="DOI" value="10.17487/RFC9001"/>
      </reference>
      <reference anchor="RETROFIT" target="https://www.ietf.org/archive/id/draft-nottingham-http-structure-retrofit-00.txt">
        <front>
          <title>Retrofit Structured Fields for HTTP</title>
          <author fullname="Mark Nottingham">
	 </author>
          <date day="6" month="October" year="2021"/>
          <abstract>
            <t>   This specification defines how a selection of existing HTTP fields
   can be handled as Structured Fields.

            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-nottingham-http-structure-retrofit-00"/>
      </reference>
      <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174">
        <front>
          <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
          <author fullname="B. Leiba" initials="B." surname="Leiba">
            <organization/>
          </author>
          <date month="May" year="2017"/>
          <abstract>
            <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="8174"/>
        <seriesInfo name="DOI" value="10.17487/RFC8174"/>
      </reference>
    </references>
  </back>
  <!-- ##markdown-source:
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
nGAKKg6C/wHMStqmjDMAAA==

-->

</rfc>
