<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-nottingham-binary-structured-headers-03" category="std" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.9.1 -->
  <front>
    <title>Binary Structured HTTP Field Values</title>
    <seriesInfo name="Internet-Draft" value="draft-nottingham-binary-structured-headers-03"/>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <postal>
          <postalLine>Prahran</postalLine>
          <postalLine>VIC</postalLine>
          <postalLine>Australia</postalLine>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <date/>
    <area>General</area>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</t>
      <t>It also defines how to use Structured Fields for many existing fields -- thereby "backporting" them -- when supported by both peers.</t>
    </abstract>
    <note>
      <name>Note to Readers</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>
      <t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>
      <t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>
      <t>See also the draft's current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>
    </note>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Structured Field Values for HTTP <xref target="RFC8941" format="default"/> offers a set of data types that new fields can use to express their semantics in a familiar textual syntax. This specification defines an alternative, binary serialisation of those structures in <xref target="fields" format="default"/>, and specifies its use in HTTP/2 in <xref target="negotiate" format="default"/>.</t>
      <t>Additionally, <xref target="backport" format="default"/> defines how to convey existing fields as Structured Fields, when supported by two peers.</t>
      <t>The primary goal is to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</t>
      <section anchor="notational-conventions" numbered="true" toc="default">
        <name>Notational Conventions</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when, and only when, they appear in all capitals, as
shown here.</t>
        <t>This specification describes formats using the convention described in <xref section="1.3" sectionFormat="of" target="I-D.ietf-quic-transport" format="default"/>.</t>
      </section>
    </section>
    <section anchor="fields" numbered="true" toc="default">
      <name>Binary Structured Fields</name>
      <t>This section defines a binary serialisation for the Structured Field Types defined in <xref target="RFC8941" format="default"/>.</t>
      <t>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Representation (<xref target="binlit" format="default"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541" format="default"/>.</t>
      <t>Binary representations of the remaining structured field types are defined in <xref target="types" format="default"/>.</t>
      <section anchor="binlit" numbered="true" toc="default">
        <name>Binary Representations</name>
        <t>Binary Representations are a replacement for the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/>, and can be used to serialise any field, including but not limited to those defined as Structured Fields.</t>
        <t>All Binary Representations share the following header:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Representation {
  Top Level Type (3),
  Length (5..),
}
]]></artwork>
        <t>Its fields are:</t>
        <ul spacing="normal">
          <li>Top Level Type: Three bits indicating the top-level type of the field value.</li>
          <li>Length: The number of octets used to represent the payload, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 5-bit prefix.</li>
        </ul>
        <t>The following top-level types are defined:</t>
        <section anchor="literal" numbered="true" toc="default">
          <name>Binary Literal Field Values</name>
          <t>Binary Literal field values (type=0x0) carry the string value of a field; they are used to carry field values that are not structured using the data types defined in <xref section="3" sectionFormat="of" target="RFC8941" format="default"/>. This might be because the field is not recognised as a Structured Field, or it might be because a field that is understood to be a Structured Field cannot be parsed successfully as one.</t>
          <t>A binary literal field value's payload is the raw octets of the field value. As such, they are functionally equivalent to String Literal Representations in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/>.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Literal Field Value {
  Top Level Type (3) = 0,
  Length (5..),
  Payload (..)
}
]]></artwork>
        </section>
        <section anchor="list-field-values" numbered="true" toc="default">
          <name>List Field Values</name>
          <t>Structured fields whose values are known to be a List as per <xref section="3.1" sectionFormat="of" target="RFC8941" format="default"/> can be conveyed as a binary representation with a top level type of 0x1. They have a payload consisting of one or more Binary Data Types (<xref target="types" format="default"/>) representing the members of the list.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Binary Data Type (..) ...
}
]]></artwork>
        </section>
        <section anchor="dictionary-field-values" numbered="true" toc="default">
          <name>Dictionary Field Values</name>
          <t>Structured fields whose values are known to be a Dictionary as per <xref section="3.2" sectionFormat="of" target="RFC8941" format="default"/> can be conveyed in a binary representation with a top level type of 0x2. They have a payload consisting of one or more Dictionary Members.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
]]></artwork>
          <t>Each Dictionary member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Data Type(s) representing the member-value.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Binary Data Type (..),
  [Parameters (..)]
}

]]></artwork>
          <t>The Binary Data Type in a Dictionary Member MUST NOT be a Parameters (0x2).</t>
        </section>
        <section anchor="item-field-values" numbered="true" toc="default">
          <name>Item Field Values</name>
          <t>Structured field values that are known to be an Item as per <xref section="3.3" sectionFormat="of" target="RFC8941" format="default"/> can be conveyed in a binary representation with a top level type of 0x3. They have a payload consisting of a single Binary Data Type (<xref target="types" format="default"/>), with optional parameters (<xref target="parameters" format="default"/>).</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Binary Data Type (..),
  [Parameters (..)]
}
]]></artwork>
          <t>The Binary Data Type in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
        </section>
      </section>
      <section anchor="parameters" numbered="true" toc="default">
        <name>Parameters</name>
      </section>
      <section anchor="types" numbered="true" toc="default">
        <name>Binary Data Types</name>
        <t>Binary data types are discrete values that are composed into binary representations (<xref target="binlit" format="default"/>) to represent the structured field values.</t>
        <t>Every binary data type starts with a 4-bit type field that identifies the format of its payload.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Data Type {
  Type (4)
}
]]></artwork>
        <t>Some data types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>
        <section anchor="inner-list" numbered="true" toc="default">
          <name>Inner Lists</name>
          <t>The Inner List data type (type=0x1) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Inner List {
  Type (4) = 1,
  Length (4..),
  Binary Data Type (..) ...
}
]]></artwork>
          <t>A Binary Data Type in an Inner List MUST NOT be an Inner List (0x1).</t>
          <t>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<xref target="parameter" format="default"/>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</t>
        </section>
        <section anchor="parameter" numbered="true" toc="default">
          <name>Parameters</name>
          <t>The Parameters data type (type=0x2) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameters {
  Type (4) = 2,
  Length (4..),
  Parameter (..) ...
}
]]></artwork>
          <t>Each Parameter conveys a key and a value:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Binary Data Type (..)
}
]]></artwork>
          <t>A parameter's fields are:</t>
          <ul spacing="normal">
            <li>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 8-bit prefix</li>
            <li>Parameter Name: Parameter Name Length octets of the parameter-name</li>
            <li>Binary Data Type: The parameter value, a Binary Data Type</li>
          </ul>
          <t>The Binary Data Type in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
          <t>Parameters are always associated with the Binary Data Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Binary Data Type in a Binary Representation, and MUST NOT follow another Parameters.</t>
        </section>
        <section anchor="integers" numbered="true" toc="default">
          <name>Integers</name>
          <t>The Integer data type (type=0x3) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Integer {
  Type (4) = 3,
  Sign (1),
  Payload (3..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Payload: The integer, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 2-bit prefix</li>
          </ul>
        </section>
        <section anchor="floats" numbered="true" toc="default">
          <name>Floats</name>
          <t>The Float data type (type=0x4) have a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Float {
  Type (4) = 4,
  Sign (1),
  Integer (3..),
  Fractional (8..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Integer: The integer component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 2-bit prefix.</li>
            <li>Fractional: The fractional component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 8-bit prefix.</li>
          </ul>
        </section>
        <section anchor="strings" numbered="true" toc="default">
          <name>Strings</name>
          <t>The String data type (type=0x5) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
String {
  Type (4) = 5,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>Its payload is Length octets long and ASCII-encoded.</t>
        </section>
        <section anchor="token" numbered="true" toc="default">
          <name>Tokens</name>
          <t>The Token data type (type=0x6) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Token {
  Type (4) = 6,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>Its payload is Length octets long and ASCII-encoded.</t>
        </section>
        <section anchor="byte-sequences" numbered="true" toc="default">
          <name>Byte Sequences</name>
          <t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Byte Sequence {
  Type (4) = 7,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>The payload is the raw octets of the byte sequence.</t>
        </section>
        <section anchor="booleans" numbered="true" toc="default">
          <name>Booleans</name>
          <t>The Boolean data type (type=0x8) has a payload of two bits:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Boolean {
  Type (4) = 8,
  Payload (1),
  Padding (3) = 0
}
]]></artwork>
          <t>If Payload is 0, the value is False; if Payload is 1, the value is True.</t>
        </section>
      </section>
    </section>
    <section anchor="negotiate" numbered="true" toc="default">
      <name>Using Binary Structured Fields in HTTP/2</name>
      <t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields (or compatible with them; see <xref target="backport" format="default"/>) as binary data, rather than strings.</t>
      <t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting" format="default"/>, and convey Binary Structured Fields in streams whose HEADERS frame uses the flag defined in <xref target="flag" format="default"/>.</t>
      <section anchor="setting" numbered="true" toc="default">
        <name>The SETTINGS_BINARY_STRUCTURED_FIELDS Setting</name>
        <t>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</t>
        <t>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS with a non-zero value from a peer indicates that:</t>
        <ol spacing="normal" type="1"><li>The peer supports the Binary Data Types defined in <xref target="fields" format="default"/>.</li>
          <li>The peer will process the BINARY_STRUCTRED HEADERS flag as defined in <xref target="flag" format="default"/>.</li>
          <li>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Fields data types defined in <xref target="RFC8941" format="default"/>).</li>
          <li>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased" format="default"/>) into their non-aliased forms as necessary.</li>
        </ol>
        <t>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0, whereas a value of 1 indicates that this specification is supported with no further extensions. Future specifications might use values greater than one to indicate support for extensions.</t>
      </section>
      <section anchor="flag" numbered="true" toc="default">
        <name>The BINARY_STRUCTRED HEADERS Flag</name>
        <t>When a peer has indicated that it supports this specification as per <xref target="setting" format="default"/>, a sender can send the BINARY_STRUCTURED flag (0xTODO) on the HEADERS frame.</t>
        <t>This flag indicates that the HEADERS frame containing it and subsequent CONTINUATION frames on the same stream use the Binary Representation defined in <xref target="binlit" format="default"/> instead of the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/> for all field values. Field names are still serialised as String Literal Representations.</t>
        <t>In such frames, field values that are known to be Structured Fields and those that can be converted to Structured Fields (as per <xref target="backport" format="default"/>) MAY be sent using the applicable Binary Representation. However, any field value (including those defined as Structured Fields) can also be serialised as a Binary Literal (<xref target="literal" format="default"/>) to accommodate fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as a Structured Field for some other reason.</t>
        <t>Binary Representations are stored in the HPACK <xref target="RFC7541" format="default"/> dynamic table, and their lengths are used for the purposes of maintaining dynamic table size (<xref section="4" sectionFormat="comma" target="RFC7541" format="default"/>).</t>
        <t>Note that HEADERS frames with and without the BINARY_STRUCTURED flag MAY be mixed on the same connection, depending on the requirements of the sender.</t>
      </section>
    </section>
    <section anchor="backport" numbered="true" toc="default">
      <name>Using Binary Structured Fields with Existing Fields</name>
      <t>Any field can potentially be parsed as a Structured Field according to the algorithms in <xref target="RFC8941" format="default"/> and serialised as a Binary Structured Field. However, many cannot, so optimistically parsing them can be expensive.</t>
      <t>This section identifies fields that will usually succeed in <xref target="direct" format="default"/>, and those that can be mapped into Structured Fields by using an alias field name in <xref target="aliased" format="default"/>.</t>
      <section anchor="direct" numbered="true" toc="default">
        <name>Directly Represented Fields</name>
        <t>The following HTTP field names can have their values parsed as Structured Fields according to the algorithms in <xref target="RFC8941" format="default"/>, and thus can usually be serialised using the corresponding Binary Data Types.</t>
        <t>When one of these fields' values cannot be represented using Structured Types in a Binary Representation, its value can instead be represented as a Binary Literal (<xref target="literal" format="default"/>).</t>
        <ul spacing="normal">
          <li>Accept - List</li>
          <li>Accept-Encoding - List</li>
          <li>Accept-Language - List</li>
          <li>Accept-Patch - List</li>
          <li>Accept-Ranges - List</li>
          <li>Access-Control-Allow-Credentials - Item</li>
          <li>Access-Control-Allow-Headers - List</li>
          <li>Access-Control-Allow-Methods - List</li>
          <li>Access-Control-Allow-Origin - Item</li>
          <li>Access-Control-Max-Age - Item</li>
          <li>Access-Control-Request-Headers - List</li>
          <li>Access-Control-Request-Method - Item</li>
          <li>Age - Item</li>
          <li>Allow - List</li>
          <li>ALPN - List</li>
          <li>Alt-Svc - Dictionary</li>
          <li>Alt-Used - Item</li>
          <li>Cache-Control - Dictionary</li>
          <li>Connection - List</li>
          <li>Content-Encoding - List</li>
          <li>Content-Language - List</li>
          <li>Content-Length - Item</li>
          <li>Content-Type - Item</li>
          <li>Expect - Item</li>
          <li>Expect-CT - Dictionary</li>
          <li>Forwarded - Dictionary</li>
          <li>Host - Item</li>
          <li>Keep-Alive - Dictionary</li>
          <li>Origin - Item</li>
          <li>Pragma - Dictionary</li>
          <li>Prefer - Dictionary</li>
          <li>Preference-Applied - Dictionary</li>
          <li>Retry-After - Item  (see caveat below)</li>
          <li>Surrogate-Control - Dictionary</li>
          <li>TE - List</li>
          <li>Trailer - List</li>
          <li>Transfer-Encoding - List</li>
          <li>Vary - List</li>
          <li>X-Content-Type-Options - Item</li>
          <li>X-XSS-Protection - List</li>
        </ul>
        <t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Binary Literal (<xref target="literal" format="default"/>).</t>
      </section>
      <section anchor="aliased" numbered="true" toc="default">
        <name>Aliased Fields</name>
        <t>The following HTTP field names can have their values represented in Structured Fields by mapping them into its data types and then serialising the resulting Structured Field using an alternative field name.</t>
        <t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork>
        <t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured Fields as:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Date: 784072177
]]></artwork>
        <t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Binary Literal (<xref target="literal" format="default"/>).</t>
        <t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate" format="default"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>
        <t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Fields.</t>
        <ul spacing="normal">
          <li>ISSUE: using separate names assures that the different syntax doesn't "leak" into normal fields, but it isn't strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn't understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></li>
        </ul>
        <section anchor="urls" numbered="true" toc="default">
          <name>URLs</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by considering their payload a string.</t>
          <ul spacing="normal">
            <li>Content-Location - SF-Content-Location</li>
            <li>Location - SF-Location</li>
            <li>Referer - SF-Referer</li>
          </ul>
          <t>For example, a (non-binary) Location:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Location: "https://example.com/foo"
]]></artwork>
          <t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>
        </section>
        <section anchor="dates" numbered="true" toc="default">
          <name>Dates</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by parsing their payload according to <xref target="RFC7231" format="default"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>
          <ul spacing="normal">
            <li>Date - SF-Date</li>
            <li>Expires - SF-Expires</li>
            <li>If-Modified-Since - SF-IMS</li>
            <li>If-Unmodified-Since - SF-IUS</li>
            <li>Last-Modified - SF-LM</li>
          </ul>
          <t>For example, a (non-binary) Expires:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Expires: 1571965240
]]></artwork>
        </section>
        <section anchor="etags" numbered="true" toc="default">
          <name>ETags</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by representing the entity-tag as a string, and the weakness flag as a boolean "w" parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>
          <ul spacing="normal">
            <li>ETag - SF-ETag</li>
          </ul>
          <t>For example, a (non-Binary) ETag:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-ETag: "abcdef"; w=?1
]]></artwork>
          <t>If-None-Match is a list of the structure described above.</t>
          <ul spacing="normal">
            <li>If-None-Match - SF-INM</li>
          </ul>
          <t>For example, a (non-binary) If-None-Match:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork>
        </section>
        <section anchor="links" numbered="true" toc="default">
          <name>Links</name>
          <t>The field-value of the Link header field <xref target="RFC8288" format="default"/> can be represented in Binary Structured Fields by representing the URI-Reference as a string, and link-param as parameters.</t>
          <ul spacing="normal">
            <li>Link: SF-Link</li>
          </ul>
          <t>For example, a (non-binary) Link:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork>
        </section>
        <section anchor="cookies" numbered="true" toc="default">
          <name>Cookies</name>
          <t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265" format="default"/> can be represented in Binary Structured Fields as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>
          <t>Set-Cookie: SF-Set-Cookie
Cookie: SF-Cookie</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SF-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork>
          <ul spacing="normal">
            <li>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></li>
            <li>ISSUE: dictionary keys cannot contain UC alpha. <eref target="https://github.com/mnot/I-D/issues/312">https://github.com/mnot/I-D/issues/312</eref></li>
            <li>ISSUE: explicitly allow non-string content. <eref target="https://github.com/mnot/I-D/issues/313">https://github.com/mnot/I-D/issues/313</eref></li>
          </ul>
        </section>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <ul spacing="normal">
        <li>ISSUE: todo</li>
      </ul>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>
      <t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of Binary Literals (<xref target="literal" format="default"/>). Therefore, implementation divergence from this strictness can have security impact.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author fullname="S. Bradner" initials="S." surname="Bradner">
            <organization/>
          </author>
          <date month="March" year="1997"/>
          <abstract>
            <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <seriesInfo name="DOI" value="10.17487/RFC2119"/>
      </reference>
      <reference anchor="RFC7541" target="https://www.rfc-editor.org/info/rfc7541">
        <front>
          <title>HPACK: Header Compression for HTTP/2</title>
          <author fullname="R. Peon" initials="R." surname="Peon">
            <organization/>
          </author>
          <author fullname="H. Ruellan" initials="H." surname="Ruellan">
            <organization/>
          </author>
          <date month="May" year="2015"/>
          <abstract>
            <t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7541"/>
        <seriesInfo name="DOI" value="10.17487/RFC7541"/>
      </reference>
      <reference anchor="I-D.ietf-quic-transport" target="https://www.ietf.org/archive/id/draft-ietf-quic-transport-34.txt">
        <front>
          <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
          <author fullname="Jana Iyengar">
            <organization>Fastly</organization>
          </author>
          <author fullname="Martin Thomson">
            <organization>Mozilla</organization>
          </author>
          <date day="14" month="January" year="2021"/>
          <abstract>
            <t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration.  QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.
            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-quic-transport-34"/>
      </reference>
      <reference anchor="RFC8941" target="https://www.rfc-editor.org/info/rfc8941">
        <front>
          <title>Structured Field Values for HTTP</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <author fullname="P-H. Kamp" initials="P-H." surname="Kamp">
            <organization/>
          </author>
          <date month="February" year="2021"/>
          <abstract>
            <t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8941"/>
        <seriesInfo name="DOI" value="10.17487/RFC8941"/>
      </reference>
      <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174">
        <front>
          <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
          <author fullname="B. Leiba" initials="B." surname="Leiba">
            <organization/>
          </author>
          <date month="May" year="2017"/>
          <abstract>
            <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="8174"/>
        <seriesInfo name="DOI" value="10.17487/RFC8174"/>
      </reference>
      <reference anchor="RFC7231" target="https://www.rfc-editor.org/info/rfc7231">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
          <author fullname="R. Fielding" initials="R." role="editor" surname="Fielding">
            <organization/>
          </author>
          <author fullname="J. Reschke" initials="J." role="editor" surname="Reschke">
            <organization/>
          </author>
          <date month="June" year="2014"/>
          <abstract>
            <t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7231"/>
        <seriesInfo name="DOI" value="10.17487/RFC7231"/>
      </reference>
      <reference anchor="RFC8288" target="https://www.rfc-editor.org/info/rfc8288">
        <front>
          <title>Web Linking</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <date month="October" year="2017"/>
          <abstract>
            <t>This specification defines a model for the relationships between resources on the Web ("links") and the type of those relationships ("link relation types").</t>
            <t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8288"/>
        <seriesInfo name="DOI" value="10.17487/RFC8288"/>
      </reference>
      <reference anchor="RFC6265" target="https://www.rfc-editor.org/info/rfc6265">
        <front>
          <title>HTTP State Management Mechanism</title>
          <author fullname="A. Barth" initials="A." surname="Barth">
            <organization/>
          </author>
          <date month="April" year="2011"/>
          <abstract>
            <t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="6265"/>
        <seriesInfo name="DOI" value="10.17487/RFC6265"/>
      </reference>
    </references>
    <section anchor="data-supporting-directly-represented-field-mappings" numbered="true" toc="default">
      <name>Data Supporting Directly Represented Field Mappings</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>To help guide decisions about Directly Represented Fields, the HTTP response headers captured by the HTTP Archive <eref target="https://httparchive.org">https://httparchive.org</eref> in February 2020, representing more than 350,000,000 HTTP exchanges, were parsed as Structured Fields using the types listed in <xref target="direct" format="default"/>, with the indicated number of successful header instances, failures, and the resulting failure rate:</t>
      <ul spacing="normal">
        <li>accept: 9,198 / 10 = 0.109%</li>
        <li>accept-encoding: 34,157 / 74 = 0.216%</li>
        <li>accept-language: 381,034 / 512 = 0.134%</li>
        <li>accept-patch: 5 / 0 = 0.000%</li>
        <li>accept-ranges: 197,746,643 / 3,960 = 0.002%</li>
        <li>access-control-allow-credentials: 16,684,916 / 7,438 = 0.045%</li>
        <li>access-control-allow-headers: 12,976,838 / 15,074 = 0.116%</li>
        <li>access-control-allow-methods: 15,466,748 / 28,203 = 0.182%</li>
        <li>access-control-allow-origin: 105,307,402 / 271,359 = 0.257%</li>
        <li>access-control-max-age: 5,284,663 / 7,754 = 0.147%</li>
        <li>access-control-request-headers: 39,328 / 624 = 1.562%</li>
        <li>access-control-request-method: 146,259 / 13,821 = 8.634%</li>
        <li>age: 71,281,684 / 172,398 = 0.241%</li>
        <li>allow: 351,704 / 1,886 = 0.533%</li>
        <li>alt-svc: 19,775,126 / 15,680,528 = 44.226%</li>
        <li>cache-control: 264,805,256 / 782,896 = 0.295%</li>
        <li>connection: 105,876,072 / 2,915 = 0.003%</li>
        <li>content-encoding: 139,799,523 / 379 = 0.000%</li>
        <li>content-language: 2,367,162 / 728 = 0.031%</li>
        <li>content-length: 296,624,718 / 787,843 = 0.265%</li>
        <li>content-type: 341,918,716 / 795,676 = 0.232%</li>
        <li>expect: 0 / 47 = 100.000%</li>
        <li>expect-ct: 26,569,605 / 29,114 = 0.109%</li>
        <li>forwarded: 119 / 35 = 22.727%</li>
        <li>host: 25,333 / 1,441 = 5.382%</li>
        <li>keep-alive: 43,061,546 / 796 = 0.002%</li>
        <li>origin: 24,335 / 1,539 = 5.948%</li>
        <li>pragma: 46,820,588 / 81,700 = 0.174%</li>
        <li>preference-applied: 57 / 0 = 0.000%</li>
        <li>retry-after: 605,844 / 6,195 = 1.012%</li>
        <li>strict-transport-security: 26,825,957 / 35,258,808 = 56.791%</li>
        <li>surrogate-control: 121,118 / 861 = 0.706%</li>
        <li>te: 1 / 0 = 0.000%</li>
        <li>trailer: 282 / 0 = 0.000%</li>
        <li>transfer-encoding: 13,952,661 / 0 = 0.000%</li>
        <li>vary: 150,787,199 / 41,313 = 0.027%</li>
        <li>x-content-type-options: 99,968,016 / 208,885 = 0.209%</li>
        <li>x-xss-protection: 79,871,948 / 362,979 = 0.452%</li>
      </ul>
      <t>This data set focuses on response headers, although some request headers are present (because, the Web).</t>
      <t><tt>alt-svc</tt> has a high failure rate because some currently-used ALPN tokens (e.g., <tt>h3-Q43</tt>) do not conform to key's syntax. Since the final version of HTTP/3 will use the <tt>h3</tt> token, this shouldn't be a long-term issue, although future tokens may again violate this assumption.</t>
      <t><tt>forwarded</tt> has a high failure rate because many senders use the unquoted form for IP addresses, which makes integer parsing fail; e.g., <tt>for=192.168.1.1</tt>.</t>
      <t><tt>strict-transport-security</tt> has a high failure rate because the <tt>includeSubDomains</tt> flag does not conform to the key syntax.</t>
      <t>The top ten header fields in that data set that were not parsed as Directly Represented Fields are:</t>
      <ul spacing="normal">
        <li>date: 354,652,447</li>
        <li>server: 311,275,961</li>
        <li>last-modified: 263,832,615</li>
        <li>expires: 199,967,042</li>
        <li>status: 192,423,509</li>
        <li>etag: 172,058,269</li>
        <li>timing-allow-origin: 64,407,586</li>
        <li>x-cache: 41,740,804</li>
        <li>p3p: 39,490,058</li>
        <li>x-frame-options: 34,037,985</li>
      </ul>
    </section>
  </back>
  <!-- ##markdown-source:
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
GkcdhqXWANexEwyc0bBHV3Na/wtCkenpwlgAAA==

-->

</rfc>
