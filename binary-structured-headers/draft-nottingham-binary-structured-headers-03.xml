<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.6 -->
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-nottingham-binary-structured-headers-03" category="std" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.10.0 -->
  <front>
    <title>Binary Structured HTTP Field Values</title>
    <seriesInfo name="Internet-Draft" value="draft-nottingham-binary-structured-headers-03"/>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization/>
      <address>
        <postal>
          <postalLine>Prahran</postalLine>
          <postalLine>VIC</postalLine>
          <postalLine>Australia</postalLine>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <date/>
    <area>General</area>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</t>
    </abstract>
    <note>
      <name>Note to Readers</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>
      <t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>
      <t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>
      <t>See also the draft's current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>
    </note>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Structured Field Values for HTTP <xref target="STRUCTURED-FIELDS" format="default"/> offers a set of data types that new fields can use to express their semantics in a familiar textual syntax. This specification defines an alternative, binary serialisation of those structures in <xref target="fields" format="default"/>, and specifies its use in HTTP/2 in <xref target="negotiate" format="default"/>.</t>
      <t>The primary goal is to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</t>
      <section anchor="notational-conventions" numbered="true" toc="default">
        <name>Notational Conventions</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when, and only when, they appear in all capitals, as
shown here.</t>
        <t>This specification describes formats using the convention described in <xref section="1.3" sectionFormat="of" target="QUIC" format="default"/>.</t>
      </section>
    </section>
    <section anchor="fields" numbered="true" toc="default">
      <name>Binary Structured Fields</name>
      <t>This section defines a binary serialisation for the Structured Field Types defined in <xref target="STRUCTURED-FIELDS" format="default"/>.</t>
      <t>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Representation (<xref target="binlit" format="default"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541" format="default"/>.</t>
      <t>Binary representations of the remaining structured field types are defined in <xref target="types" format="default"/>.</t>
      <section anchor="binlit" numbered="true" toc="default">
        <name>Binary Representations</name>
        <t>Binary Representations are a replacement for the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/>, and can be used to serialise any field, including but not limited to those defined as Structured Fields.</t>
        <t>All Binary Representations share the following header:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Representation {
  Top Level Type (3),
  Length (5..),
}
]]></artwork>
        <t>Its fields are:</t>
        <ul spacing="normal">
          <li>Top Level Type: Three bits indicating the top-level type of the field value.</li>
          <li>Length: The number of octets used to represent the entire field value (including the header), encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 5-bit prefix.</li>
        </ul>
        <t>The following top-level types are defined:</t>
        <section anchor="literal" numbered="true" toc="default">
          <name>Binary Literal Field Values</name>
          <t>Binary Literal field values (type=0x0) carry the string value of a field; they are used to carry field values that are not structured using the data types defined in <xref section="3" sectionFormat="of" target="STRUCTURED-FIELDS" format="default"/>. This might be because the field is not recognised as a Structured Field, or it might be because a field that is understood to be a Structured Field cannot be parsed successfully as one.</t>
          <t>A binary literal field value's payload is the raw octets of the field value. As such, they are functionally equivalent to String Literal Representations in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/>.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Literal Field Value {
  Top Level Type (3) = 0,
  Length (5..),
  Payload (..)
}
]]></artwork>
        </section>
        <section anchor="list-field-values" numbered="true" toc="default">
          <name>List Field Values</name>
          <t>Structured fields whose values are known to be a List as per <xref section="3.1" sectionFormat="of" target="STRUCTURED-FIELDS" format="default"/> can be conveyed as a binary representation with a top level type of 0x1. They have a payload consisting of one or more Binary Data Types (<xref target="types" format="default"/>) representing the members of the list.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Binary Data Type (..) ...
}
]]></artwork>
        </section>
        <section anchor="dictionary-field-values" numbered="true" toc="default">
          <name>Dictionary Field Values</name>
          <t>Structured fields whose values are known to be a Dictionary as per <xref section="3.2" sectionFormat="of" target="STRUCTURED-FIELDS" format="default"/> can be conveyed in a binary representation with a top level type of 0x2. They have a payload consisting of one or more Dictionary Members.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
]]></artwork>
          <t>Each Dictionary member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Data Type(s) representing the member-value.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Binary Data Type (..),
  [Parameters (..)]
}

]]></artwork>
          <t>The Binary Data Type in a Dictionary Member MUST NOT be a Parameters (0x2).</t>
        </section>
        <section anchor="item-field-values" numbered="true" toc="default">
          <name>Item Field Values</name>
          <t>Structured field values that are known to be an Item as per <xref section="3.3" sectionFormat="of" target="STRUCTURED-FIELDS" format="default"/> can be conveyed in a binary representation with a top level type of 0x3. They have a payload consisting of a single Binary Data Type (<xref target="types" format="default"/>), with optional parameters (<xref target="parameter" format="default"/>).</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Binary Data Type (..),
  [Parameters (..)]
}
]]></artwork>
          <t>The Binary Data Type in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
        </section>
      </section>
      <section anchor="types" numbered="true" toc="default">
        <name>Binary Data Types</name>
        <t>Binary data types are discrete values that are composed into binary representations (<xref target="binlit" format="default"/>) to represent the structured field values.</t>
        <t>Every binary data type starts with a 4-bit type field that identifies the format of its payload.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Data Type {
  Type (4)
}
]]></artwork>
        <t>Some data types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>
        <section anchor="inner-list" numbered="true" toc="default">
          <name>Inner Lists</name>
          <t>The Inner List data type (type=0x1) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Inner List {
  Type (4) = 1,
  Length (4..),
  Binary Data Type (..) ...
}
]]></artwork>
          <t>Length conveys the number of octets used to represent the inner list, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 4-bit prefix.</t>
          <t>A Binary Data Type in an Inner List MUST NOT be an Inner List (0x1).</t>
          <t>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<xref target="parameter" format="default"/>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</t>
        </section>
        <section anchor="parameter" numbered="true" toc="default">
          <name>Parameters</name>
          <t>The Parameters data type (type=0x2) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameters {
  Type (4) = 2,
  Length (4..),
  Parameter (..) ...
}
]]></artwork>
          <t>Length conveys the number of octets used to represent the parameters, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 4-bit prefix.</t>
          <t>Each Parameter conveys a key and a value:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Binary Data Type (..)
}
]]></artwork>
          <t>A parameter's fields are:</t>
          <ul spacing="normal">
            <li>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 8-bit prefix</li>
            <li>Parameter Name: Parameter Name Length octets of the parameter-name</li>
            <li>Binary Data Type: The parameter value, a Binary Data Type</li>
          </ul>
          <t>The Binary Data Type in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
          <t>Parameters are always associated with the Binary Data Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Binary Data Type in a Binary Representation, and MUST NOT follow another Parameters.</t>
        </section>
        <section anchor="integers" numbered="true" toc="default">
          <name>Integers</name>
          <t>The Integer data type (type=0x3) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Integer {
  Type (4) = 3,
  Sign (1),
  Payload (3..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Payload: The integer, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 2-bit prefix</li>
          </ul>
        </section>
        <section anchor="floats" numbered="true" toc="default">
          <name>Floats</name>
          <t>The Float data type (type=0x4) have a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Float {
  Type (4) = 4,
  Sign (1),
  Integer (3..),
  Fractional (8..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Integer: The integer component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 2-bit prefix.</li>
            <li>Fractional: The fractional component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 8-bit prefix.</li>
          </ul>
        </section>
        <section anchor="strings" numbered="true" toc="default">
          <name>Strings</name>
          <t>The String data type (type=0x5) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
String {
  Type (4) = 5,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>Its payload is Length octets long and ASCII-encoded.</t>
        </section>
        <section anchor="token" numbered="true" toc="default">
          <name>Tokens</name>
          <t>The Token data type (type=0x6) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Token {
  Type (4) = 6,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>Its payload is Length octets long and ASCII-encoded.</t>
        </section>
        <section anchor="byte-sequences" numbered="true" toc="default">
          <name>Byte Sequences</name>
          <t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Byte Sequence {
  Type (4) = 7,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>The payload is is Length octets long, containing the raw octets of the byte sequence.</t>
        </section>
        <section anchor="booleans" numbered="true" toc="default">
          <name>Booleans</name>
          <t>The Boolean data type (type=0x8) has a payload of two bits:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Boolean {
  Type (4) = 8,
  Payload (1),
  Padding (3) = 0
}
]]></artwork>
          <t>If Payload is 0, the value is False; if Payload is 1, the value is True.</t>
        </section>
      </section>
    </section>
    <section anchor="negotiate" numbered="true" toc="default">
      <name>Using Binary Structured Fields in HTTP/2</name>
      <t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields as binary data, rather than strings.</t>
      <t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting" format="default"/>, and convey Binary Structured Fields in streams whose HEADERS frame uses the flag defined in <xref target="flag" format="default"/>.</t>
      <section anchor="setting" numbered="true" toc="default">
        <name>The SETTINGS_BINARY_STRUCTURED_FIELDS Setting</name>
        <t>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</t>
        <t>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS with a non-zero value from a peer indicates that:</t>
        <ol spacing="normal" type="1"><li>The peer supports all of the Binary Data Types defined in <xref target="fields" format="default"/>.</li>
          <li>The peer will process the BINARY_STRUCTRED HEADERS flag as defined in <xref target="flag" format="default"/>.</li>
          <li>
            <t>When passing the message to a downstream consumer (whether on the network or not), the peer will:
            </t>
            <ol spacing="normal" type="1"><li>Transform all fields defined as Mapped Fields in Section 1.3 of <xref target="RETROFIT" format="default"/> into their unmapped forms, removing the mapped fields.</li>
              <li>Transform the message fields into the appropriate form for that peer (e.g., the textual representation of Structured Fields data types defined in <xref target="STRUCTURED-FIELDS" format="default"/>).</li>
            </ol>
          </li>
        </ol>
        <t>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0, whereas a value of 1 indicates that this specification is supported with no further extensions. Future specifications might use values greater than one to indicate support for extensions.</t>
      </section>
      <section anchor="flag" numbered="true" toc="default">
        <name>The BINARY_STRUCTRED HEADERS Flag</name>
        <t>When a peer has indicated that it supports this specification as per <xref target="setting" format="default"/>, a sender can send the BINARY_STRUCTURED flag (0xTODO) on the HEADERS frame.</t>
        <t>This flag indicates that the HEADERS frame containing it and subsequent CONTINUATION frames on the same stream use the Binary Representation defined in <xref target="binlit" format="default"/> instead of the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/> for all field values. Field names are still serialised as String Literal Representations.</t>
        <t>In such frames, field values that are known to be Structured Fields and those that can be converted to Structured Fields (as per <xref target="RETROFIT" format="default"/>) MAY be sent using the applicable Binary Representation. However, any field value (including those defined as Structured Fields) can also be serialised as a Binary Literal (<xref target="literal" format="default"/>) to accommodate fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as a Structured Field for some other reason.</t>
        <t>Binary Representations are stored in the HPACK <xref target="RFC7541" format="default"/> dynamic table, and their lengths are used for the purposes of maintaining dynamic table size (see <xref section="4" sectionFormat="comma" target="RFC7541" format="default"/>).</t>
        <t>Note that HEADERS frames with and without the BINARY_STRUCTURED flag MAY be mixed on the same connection, depending on the requirements of the sender.</t>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <ul spacing="normal">
        <li>ISSUE: todo</li>
      </ul>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>
      <t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of Binary Literals (<xref target="literal" format="default"/>). Therefore, implementation divergence from this strictness can have security impact.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author fullname="S. Bradner" initials="S." surname="Bradner">
            <organization/>
          </author>
          <date month="March" year="1997"/>
          <abstract>
            <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <seriesInfo name="DOI" value="10.17487/RFC2119"/>
      </reference>
      <reference anchor="RFC7541" target="https://www.rfc-editor.org/info/rfc7541">
        <front>
          <title>HPACK: Header Compression for HTTP/2</title>
          <author fullname="R. Peon" initials="R." surname="Peon">
            <organization/>
          </author>
          <author fullname="H. Ruellan" initials="H." surname="Ruellan">
            <organization/>
          </author>
          <date month="May" year="2015"/>
          <abstract>
            <t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7541"/>
        <seriesInfo name="DOI" value="10.17487/RFC7541"/>
      </reference>
      <reference anchor="STRUCTURED-FIELDS" target="https://www.rfc-editor.org/info/rfc8941">
        <front>
          <title>Structured Field Values for HTTP</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <author fullname="P-H. Kamp" initials="P-H." surname="Kamp">
            <organization/>
          </author>
          <date month="February" year="2021"/>
          <abstract>
            <t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8941"/>
        <seriesInfo name="DOI" value="10.17487/RFC8941"/>
      </reference>
      <reference anchor="QUIC" target="https://www.rfc-editor.org/info/rfc9001">
        <front>
          <title>Using TLS to Secure QUIC</title>
          <author fullname="M. Thomson" initials="M." role="editor" surname="Thomson">
            <organization/>
          </author>
          <author fullname="S. Turner" initials="S." role="editor" surname="Turner">
            <organization/>
          </author>
          <date month="May" year="2021"/>
          <abstract>
            <t>This document describes how Transport Layer Security (TLS) is used to secure QUIC.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="9001"/>
        <seriesInfo name="DOI" value="10.17487/RFC9001"/>
      </reference>
      <reference anchor="RETROFIT" target="https://mnot.github.io/I-D/http-structure-retrofit/">
        <front>
          <title>Retrofit Structured Fields for HTTP</title>
          <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
            <organization/>
          </author>
          <date year="2021" month="October"/>
        </front>
      </reference>
      <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174">
        <front>
          <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
          <author fullname="B. Leiba" initials="B." surname="Leiba">
            <organization/>
          </author>
          <date month="May" year="2017"/>
          <abstract>
            <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="8174"/>
        <seriesInfo name="DOI" value="10.17487/RFC8174"/>
      </reference>
    </references>
  </back>
  <!-- ##markdown-source:
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
OAj+B/ajtgwTNAAA

-->

</rfc>
