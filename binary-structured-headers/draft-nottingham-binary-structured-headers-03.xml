<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-binary-structured-headers-03" category="std">

  <front>
    <title>Binary Structured HTTP Field Values</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <postal>
          <city>Prahran</city>
          <region>VIC</region>
          <country>Australia</country>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</t>

<t>It also defines how to use Structured Fields for many existing fields -- thereby "backporting" them -- when supported by both peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><em>RFC EDITOR: please remove this section before publication</em></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>

<t>See also the draft's current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction"><name>Introduction</name>

<t>Structured Field Values for HTTP <xref target="RFC8941"/> offers a set of data types that new fields can combine to express their semantics. This specification defines a binary serialisation of those structures in <xref target="fields"/>, and specifies its use in HTTP/2 in <xref target="negotiate"/>.</t>

<t>Additionally, <xref target="backport"/> defines how to convey existing fields as Structured Fields, when supported by two peers.</t>

<t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</t>

<section anchor="notational-conventions"><name>Notational Conventions</name>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This specification describes formats using the convention described in <xref section="1.3" sectionFormat="of" target="I-D.ietf-quic-transport"/>.</t>

</section>
</section>
<section anchor="fields"><name>Binary Structured Fields</name>

<t>This section defines a binary serialisation for the Structured Field Types defined in <xref target="RFC8941"/>.</t>

<t>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Representation (<xref target="binlit"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541"/>.</t>

<t>Binary representations of the remaining structured field types are defined in <xref target="types"/>.</t>

<section anchor="binlit"><name>Binary Representations</name>

<t>Binary Representations are a replacement for the String Literal Representation defined in <xref section="5.2." sectionFormat="of" target="RFC7541"/>, and can be used to serialise a Structured Field Type.</t>

<t>All Binary Representations share the following header:</t>

<figure><artwork><![CDATA[
Binary Representation {
  Top Level Type (3),
  Length (5..),
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Top Level Type: Three bits indicating the top-level type of the field value.</t>
  <t>Length: The number of octets used to represent the payload, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 5-bit prefix.</t>
</list></t>

<t>The following top-level types are defined:</t>

<section anchor="list-field-values"><name>List Field Values</name>

<t>List values (type=0x1) have a payload consisting of a stream of Binary Item Types representing the members of the list. Members that are Items are represented as per <xref target="types"/>; members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<figure><artwork><![CDATA[
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Item (..) ...
}
]]></artwork></figure>

<t>A List Field Value's fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the entire List, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 5-bit prefix</t>
  <t>Item: One or more Item(s) (<xref target="types"/>)</t>
</list></t>

</section>
<section anchor="dictionary-field-values"><name>Dictionary Field Values</name>

<t>Dictionary values (type=0x2) have a payload consisting of a stream of Dictionary Members.</t>

<t>Each member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Item Type(s) representing the member-value.</t>

<figure><artwork><![CDATA[
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
]]></artwork></figure>

<t>A Dictionary Field Value's fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the entire Dictionary, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 5-bit prefix</t>
  <t>Dictionary Member: one or more Dictionary Member(s)</t>
</list></t>

<figure><artwork><![CDATA[
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Item (..),
  [Parameters (..)]
}

]]></artwork></figure>

<t>A Dictionary Member's fields are:</t>

<t><list style="symbols">
  <t>Name Length: The number of octets used to represent the Member Name, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 8-bit prefix</t>
  <t>Member Name: Name Length octets of the member-name, ASCII-encoded</t>
  <t>Item: An Item (<xref target="types"/>)</t>
  <t>Parameters: Optional Parameters (<xref target="parameter"/>)</t>
</list></t>

<t>The Item in a Dictionary Member MUST NOT be a Parameters (0x2).</t>

</section>
<section anchor="item-field-values"><name>Item Field Values</name>

<t>Item values (type=0x3) have a payload consisting of Binary Item Types, as described in <xref target="types"/>.</t>

<figure><artwork><![CDATA[
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Item (..)
  [Parameters (..)]
}
]]></artwork></figure>

<t>An Item Field Value's fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the Item (including Parameters, if present), encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 5-bit prefix</t>
  <t>Item: An Item (<xref target="types"/>)</t>
  <t>Parameters: Optional Parameters (<xref target="parameter"/>)</t>
</list></t>

<t>The Item in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>

</section>
<section anchor="literal"><name>Binary Literal Field Values</name>

<t>Binary Literal values (type=0x4) are the string value of a field; they are used to carry field values that are not Binary Structured Fields, and may not be Structured Fields at all. As such, their semantics are that of String Literal Representations in <xref section="5.2" sectionFormat="of" target="RFC7541"/>.</t>

<figure><artwork><![CDATA[
Binary Literal Field Value {
  Top Level Type (3) = 4,
  Length (5..),
  Payload (..)
}
]]></artwork></figure>

<t>A Binary Literal Field Value's fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the string literal, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 5-bit prefix</t>
  <t>Payload: The raw octets of the field value</t>
</list></t>

</section>
</section>
<section anchor="types"><name>Binary Data Types</name>

<t>Every data type starts with a 5-bit type field that identifies the format of its payload.</t>

<figure><artwork><![CDATA[
Binary Data Type {
  Type (5)
}
]]></artwork></figure>

<t>Some data types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>

<section anchor="inner-list"><name>Inner Lists</name>

<t>The Inner List data type (type=0x1) has a payload in the format:</t>

<figure><artwork><![CDATA[
Inner List {
  Type (5) = 1,
  Length (3..),
  Item (..) ...
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the members, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 3-bit prefix</t>
  <t>Item(s): Length octets containing the Item(s) in the List</t>
</list></t>

<t>An Item in an Inner List MUST NOT be an Inner List (0x1).</t>

<t>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<xref target="parameter"/>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</t>

</section>
<section anchor="parameter"><name>Parameters</name>

<t>The Parameters data type (type=0x2) has a payload in the format:</t>

<figure><artwork><![CDATA[
Parameters {
  Type (5) = 2,
  Length (3..),
  Parameter (..) ...
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the payload, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 3-bit prefix</t>
  <t>Parameter(s): Length octets</t>
</list></t>

<t>Each Parameter conveys a key and a value:</t>

<figure><artwork><![CDATA[
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Binary Data Type (..)
}
]]></artwork></figure>

<t>A parameter's fields are:</t>

<t><list style="symbols">
  <t>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 8-bit prefix</t>
  <t>Parameter Name: Parameter Name Length octets of the parameter-name</t>
  <t>Binary Data Type: The parameter value, a Binary Data Type</t>
</list></t>

<t>The Binary Data Type in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>

<t>Parameters are always associated with the Binary Data Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Binary Data Type in a container, and MUST NOT follow another Parameters.</t>

</section>
<section anchor="integers"><name>Integers</name>

<t>The Integer data type (type=0x3) has a payload in the format:</t>

<figure><artwork><![CDATA[
Integer {
  Type (5) = 3,
  Sign (1),
  Payload (2..)
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Sign: sign bit; 0 is negative, 1 is positive</t>
  <t>Payload: The integer, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 2-bit prefix</t>
</list></t>

</section>
<section anchor="floats"><name>Floats</name>

<t>The Float data type (type=0x4) have a payload in the format:</t>

<figure><artwork><![CDATA[
Float {
  Type (5) = 4,
  Sign (1),
  Integer (2..),
  Fractional (8..)
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Sign: sign bit; 0 is negative, 1 is positive</t>
  <t>Integer: The integer component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 2-bit prefix.</t>
  <t>Fractional: The fractional component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 8-bit prefix.</t>
</list></t>

</section>
<section anchor="strings"><name>Strings</name>

<t>The String data type (type=0x5) has a payload in the format:</t>

<figure><artwork><![CDATA[
String {
  Type (5) = 5,
  Length (3..),
  Payload (..)
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the string, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 3-bit prefix.</t>
  <t>Payload: Length octets, ASCII-encoded.</t>
</list></t>

</section>
<section anchor="token"><name>Tokens</name>

<t>The Token data type (type=0x6) has a payload in the format:</t>

<figure><artwork><![CDATA[
Token {
  Type (5) = 6,
  Length (3..),
  Payload (..)
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the token, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 3-bit prefix.</t>
  <t>Payload: Length octets, ASCII-encoded.</t>
</list></t>

</section>
<section anchor="byte-sequences"><name>Byte Sequences</name>

<t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>

<figure><artwork><![CDATA[
Byte Sequence {
  Type (5) = 7,
  Length (3..),
  Payload (..)
}
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>Length: The number of octets used to represent the byte sequence, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541"/>, with a 3-bit prefix.</t>
  <t>Payload: Length octets.</t>
</list></t>

</section>
<section anchor="booleans"><name>Booleans</name>

<t>The Boolean data type (type=0x8) has a payload of two bits:</t>

<figure><artwork><![CDATA[
Boolean {
  Type (5) = 8,
  Payload (1),
  Padding (2) = 0
}
]]></artwork></figure>

<t>If Payload is 0, the value is False; if Payload is 1, the value is True.</t>

</section>
</section>
</section>
<section anchor="negotiate"><name>Using Binary Structured Fields in HTTP/2</name>

<t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields (or compatible with them; see <xref target="backport"/>) as binary data, rather than strings.</t>

<t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting"/>, and convey Binary Structured Fields in streams whose HEADERS frame uses the flag defined in <xref target="flag"/>.</t>

<section anchor="setting"><name>The SETTINGS_BINARY_STRUCTURED_FIELDS Setting</name>

<t>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS with a non-zero value from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the Binary Item Types defined in <xref target="fields"/>.</t>
  <t>The peer will process the BINARY_STRUCTRED HEADERS flag as defined in <xref target="flag"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Fields data types defined in <xref target="RFC8941"/>).</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased"/>) into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0, whereas a value of 1 indicates that this specification is supported with no further extensions. Future specifications might use values greater than one to indicate support for extensions.</t>

</section>
<section anchor="flag"><name>The BINARY_STRUCTRED HEADERS Flag</name>

<t>When a peer has indicated that it supports this specification as per <xref target="setting"/>, a sender can send the BINARY_STRUCTURED flag (0xTODO) on the HEADERS frame.</t>

<t>This flag indicates that the HEADERS frame containing it and subsequent CONTINUATION frames on the same stream use the Binary Representation defined in <xref target="binlit"/> instead of the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541"/> for all field values. Field names are still serialised as String Literal Representations.</t>

<t>In such frames, field values that are known to be Structured Fields and those that can be converted to Structured Fields (as per <xref target="backport"/>) MAY be sent using the applicable Binary Representation. However, any field value (including those defined as Structured Fields) can also be serialised as a Binary Literal (<xref target="literal"/>) to accommodate fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as a Structured Field for some other reason.</t>

<t>Binary Representations are stored in the HPACK <xref target="RFC7541"/> dynamic table, and their lengths are used for the purposes of maintaining dynamic table size (<xref section="4" sectionFormat="comma" target="RFC7541"/>).</t>

<t>Note that HEADERS frames with and without the BINARY_STRUCTURED flag MAY be mixed on the same connection, depending on the requirements of the sender.</t>

</section>
</section>
<section anchor="backport"><name>Using Binary Structured Fields with Existing Fields</name>

<t>Any field can potentially be parsed as a Structured Field according to the algorithms in <xref target="RFC8941"/> and serialised as a Binary Structured Field. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Fields by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct"><name>Directly Represented Fields</name>

<t>The following HTTP field names can have their values parsed as Structured Fields according to the algorithms in <xref target="RFC8941"/>, and thus can usually be serialised using the corresponding Binary Item Types.</t>

<t>When one of these fields' values cannot be represented using Structured Types in a Binary Representation, its value can instead be represented as a Binary Literal (<xref target="literal"/>).</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - Dictionary</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Connection - List</t>
  <t>Content-Encoding - List</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Expect-CT - Dictionary</t>
  <t>Forwarded - Dictionary</t>
  <t>Host - Item</t>
  <t>Keep-Alive - Dictionary</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
  <t>X-XSS-Protection - List</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Binary Literal (<xref target="literal"/>).</t>

</section>
<section anchor="aliased"><name>Aliased Fields</name>

<t>The following HTTP field names can have their values represented in Structured Fields by mapping them into its data types and then serialising the resulting Structured Field using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured Fields as:</t>

<figure><artwork><![CDATA[
SF-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Binary Literal (<xref target="literal"/>).</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Fields.</t>

<t><list style="symbols">
  <t>ISSUE: using separate names assures that the different syntax doesn't "leak" into normal fields, but it isn't strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn't understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></t>
</list></t>

<section anchor="urls"><name>URLs</name>

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SF-Content-Location</t>
  <t>Location - SF-Location</t>
  <t>Referer - SF-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SF-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates"><name>Dates</name>

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by parsing their payload according to <xref target="RFC7231"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SF-Date</t>
  <t>Expires - SF-Expires</t>
  <t>If-Modified-Since - SF-IMS</t>
  <t>If-Unmodified-Since - SF-IUS</t>
  <t>Last-Modified - SF-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SF-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags"><name>ETags</name>

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by representing the entity-tag as a string, and the weakness flag as a boolean "w" parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SF-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SF-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SF-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SF-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links"><name>Links</name>

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Fields by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SF-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SF-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies"><name>Cookies</name>

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Fields as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SF-Set-Cookie
Cookie: SF-Cookie</t>

<figure><artwork><![CDATA[
SF-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SF-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t><list style="symbols">
  <t>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></t>
  <t>ISSUE: dictionary keys cannot contain UC alpha. <eref target="https://github.com/mnot/I-D/issues/312">https://github.com/mnot/I-D/issues/312</eref></t>
  <t>ISSUE: explicitly allow non-string content. <eref target="https://github.com/mnot/I-D/issues/313">https://github.com/mnot/I-D/issues/313</eref></t>
</list></t>

</section>
</section>
</section>
<section anchor="iana-considerations"><name>IANA Considerations</name>

<t><list style="symbols">
  <t>ISSUE: todo</t>
</list></t>

</section>
<section anchor="security-considerations"><name>Security Considerations</name>

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of Binary Literals (<xref target="literal"/>). Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC7541' target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author fullname='R. Peon' initials='R.' surname='Peon'><organization/></author>
<author fullname='H. Ruellan' initials='H.' surname='Ruellan'><organization/></author>
<date month='May' year='2015'/>
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>


<reference anchor='I-D.ietf-quic-transport'>
   <front>
      <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
      <author fullname='Jana Iyengar'>
	 <organization>Fastly</organization>
      </author>
      <author fullname='Martin Thomson'>
	 <organization>Mozilla</organization>
      </author>
      <date day='14' month='January' year='2021'/>
      <abstract>
	 <t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration.  QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.
	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-quic-transport-34'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-quic-transport-34.txt' type='TXT'/>
</reference>



<reference anchor='RFC8941' target='https://www.rfc-editor.org/info/rfc8941'>
<front>
<title>Structured Field Values for HTTP</title>
<author fullname='M. Nottingham' initials='M.' surname='Nottingham'><organization/></author>
<author fullname='P-H. Kamp' initials='P-H.' surname='Kamp'><organization/></author>
<date month='February' year='2021'/>
<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as &quot;Structured Fields&quot;, &quot;Structured Headers&quot;, or &quot;Structured Trailers&quot;. It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>
</front>
<seriesInfo name='RFC' value='8941'/>
<seriesInfo name='DOI' value='10.17487/RFC8941'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference anchor='RFC7231' target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author fullname='R. Fielding' initials='R.' role='editor' surname='Fielding'><organization/></author>
<author fullname='J. Reschke' initials='J.' role='editor' surname='Reschke'><organization/></author>
<date month='June' year='2014'/>
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference anchor='RFC8288' target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author fullname='M. Nottingham' initials='M.' surname='Nottingham'><organization/></author>
<date month='October' year='2017'/>
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference anchor='RFC6265' target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author fullname='A. Barth' initials='A.' surname='Barth'><organization/></author>
<date month='April' year='2011'/>
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>



<section anchor="data-supporting-directly-represented-field-mappings"><name>Data Supporting Directly Represented Field Mappings</name>

<t><em>RFC EDITOR: please remove this section before publication</em></t>

<t>To help guide decisions about Directly Represented Fields, the HTTP response headers captured by the HTTP Archive <eref target="https://httparchive.org">https://httparchive.org</eref> in February 2020, representing more than 350,000,000 HTTP exchanges, were parsed as Structured Fields using the types listed in <xref target="direct"/>, with the indicated number of successful header instances, failures, and the resulting failure rate:</t>

<t><list style="symbols">
  <t>accept: 9,198 / 10 = 0.109%</t>
  <t>accept-encoding: 34,157 / 74 = 0.216%</t>
  <t>accept-language: 381,034 / 512 = 0.134%</t>
  <t>accept-patch: 5 / 0 = 0.000%</t>
  <t>accept-ranges: 197,746,643 / 3,960 = 0.002%</t>
  <t>access-control-allow-credentials: 16,684,916 / 7,438 = 0.045%</t>
  <t>access-control-allow-headers: 12,976,838 / 15,074 = 0.116%</t>
  <t>access-control-allow-methods: 15,466,748 / 28,203 = 0.182%</t>
  <t>access-control-allow-origin: 105,307,402 / 271,359 = 0.257%</t>
  <t>access-control-max-age: 5,284,663 / 7,754 = 0.147%</t>
  <t>access-control-request-headers: 39,328 / 624 = 1.562%</t>
  <t>access-control-request-method: 146,259 / 13,821 = 8.634%</t>
  <t>age: 71,281,684 / 172,398 = 0.241%</t>
  <t>allow: 351,704 / 1,886 = 0.533%</t>
  <t>alt-svc: 19,775,126 / 15,680,528 = 44.226%</t>
  <t>cache-control: 264,805,256 / 782,896 = 0.295%</t>
  <t>connection: 105,876,072 / 2,915 = 0.003%</t>
  <t>content-encoding: 139,799,523 / 379 = 0.000%</t>
  <t>content-language: 2,367,162 / 728 = 0.031%</t>
  <t>content-length: 296,624,718 / 787,843 = 0.265%</t>
  <t>content-type: 341,918,716 / 795,676 = 0.232%</t>
  <t>expect: 0 / 47 = 100.000%</t>
  <t>expect-ct: 26,569,605 / 29,114 = 0.109%</t>
  <t>forwarded: 119 / 35 = 22.727%</t>
  <t>host: 25,333 / 1,441 = 5.382%</t>
  <t>keep-alive: 43,061,546 / 796 = 0.002%</t>
  <t>origin: 24,335 / 1,539 = 5.948%</t>
  <t>pragma: 46,820,588 / 81,700 = 0.174%</t>
  <t>preference-applied: 57 / 0 = 0.000%</t>
  <t>retry-after: 605,844 / 6,195 = 1.012%</t>
  <t>strict-transport-security: 26,825,957 / 35,258,808 = 56.791%</t>
  <t>surrogate-control: 121,118 / 861 = 0.706%</t>
  <t>te: 1 / 0 = 0.000%</t>
  <t>trailer: 282 / 0 = 0.000%</t>
  <t>transfer-encoding: 13,952,661 / 0 = 0.000%</t>
  <t>vary: 150,787,199 / 41,313 = 0.027%</t>
  <t>x-content-type-options: 99,968,016 / 208,885 = 0.209%</t>
  <t>x-xss-protection: 79,871,948 / 362,979 = 0.452%</t>
</list></t>

<t>This data set focuses on response headers, although some request headers are present (because, the Web).</t>

<t><spanx style="verb">alt-svc</spanx> has a high failure rate because some currently-used ALPN tokens (e.g., <spanx style="verb">h3-Q43</spanx>) do not conform to key's syntax. Since the final version of HTTP/3 will use the <spanx style="verb">h3</spanx> token, this shouldn't be a long-term issue, although future tokens may again violate this assumption.</t>

<t><spanx style="verb">forwarded</spanx> has a high failure rate because many senders use the unquoted form for IP addresses, which makes integer parsing fail; e.g., <spanx style="verb">for=192.168.1.1</spanx>.</t>

<t><spanx style="verb">strict-transport-security</spanx> has a high failure rate because the <spanx style="verb">includeSubDomains</spanx> flag does not conform to the key syntax.</t>

<t>The top ten header fields in that data set that were not parsed as Directly Represented Fields are:</t>

<t><list style="symbols">
  <t>date: 354,652,447</t>
  <t>server: 311,275,961</t>
  <t>last-modified: 263,832,615</t>
  <t>expires: 199,967,042</t>
  <t>status: 192,423,509</t>
  <t>etag: 172,058,269</t>
  <t>timing-allow-origin: 64,407,586</t>
  <t>x-cache: 41,740,804</t>
  <t>p3p: 39,490,058</t>
  <t>x-frame-options: 34,037,985</t>
</list></t>

</section>


  </back>

<!-- ##markdown-source:
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

-->

</rfc>

