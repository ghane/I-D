<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-nottingham-binary-structured-headers-03" category="std" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.9.1 -->
  <front>
    <title>Binary Structured HTTP Field Values</title>
    <seriesInfo name="Internet-Draft" value="draft-nottingham-binary-structured-headers-03"/>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <postal>
          <postalLine>Prahran</postalLine>
          <postalLine>VIC</postalLine>
          <postalLine>Australia</postalLine>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <date/>
    <area>General</area>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</t>
      <t>It also defines how to use Structured Fields for many existing fields -- thereby "backporting" them -- when supported by both peers.</t>
    </abstract>
    <note>
      <name>Note to Readers</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>
      <t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>
      <t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>
      <t>See also the draft's current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>
    </note>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Structured Field Values for HTTP <xref target="RFC8941" format="default"/> offers a set of data types that new fields can use to express their semantics in a familiar textual syntax. This specification defines an alternative, binary serialisation of those structures in <xref target="fields" format="default"/>, and specifies its use in HTTP/2 in <xref target="negotiate" format="default"/>.</t>
      <t>Additionally, <xref target="backport" format="default"/> defines how to convey existing fields as Structured Fields, when supported by two peers.</t>
      <t>The primary goal is to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</t>
      <section anchor="notational-conventions" numbered="true" toc="default">
        <name>Notational Conventions</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when, and only when, they appear in all capitals, as
shown here.</t>
        <t>This specification describes formats using the convention described in <xref section="1.3" sectionFormat="of" target="I-D.ietf-quic-transport" format="default"/>.</t>
      </section>
    </section>
    <section anchor="fields" numbered="true" toc="default">
      <name>Binary Structured Fields</name>
      <t>This section defines a binary serialisation for the Structured Field Types defined in <xref target="RFC8941" format="default"/>.</t>
      <t>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Representation (<xref target="binlit" format="default"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541" format="default"/>.</t>
      <t>Binary representations of the remaining structured field types are defined in <xref target="types" format="default"/>.</t>
      <section anchor="binlit" numbered="true" toc="default">
        <name>Binary Representations</name>
        <t>Binary Representations are a replacement for the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/>, and can be used to serialise any field, including but not limited to those defined as Structured Fields.</t>
        <t>All Binary Representations share the following header:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Representation {
  Top Level Type (3),
  Length (5..),
}
]]></artwork>
        <t>Its fields are:</t>
        <ul spacing="normal">
          <li>Top Level Type: Three bits indicating the top-level type of the field value.</li>
          <li>Length: The number of octets used to represent the entire field value (including the header), encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 5-bit prefix.</li>
        </ul>
        <t>The following top-level types are defined:</t>
        <section anchor="literal" numbered="true" toc="default">
          <name>Binary Literal Field Values</name>
          <t>Binary Literal field values (type=0x0) carry the string value of a field; they are used to carry field values that are not structured using the data types defined in <xref section="3" sectionFormat="of" target="RFC8941" format="default"/>. This might be because the field is not recognised as a Structured Field, or it might be because a field that is understood to be a Structured Field cannot be parsed successfully as one.</t>
          <t>A binary literal field value's payload is the raw octets of the field value. As such, they are functionally equivalent to String Literal Representations in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/>.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Literal Field Value {
  Top Level Type (3) = 0,
  Length (5..),
  Payload (..)
}
]]></artwork>
        </section>
        <section anchor="list-field-values" numbered="true" toc="default">
          <name>List Field Values</name>
          <t>Structured fields whose values are known to be a List as per <xref section="3.1" sectionFormat="of" target="RFC8941" format="default"/> can be conveyed as a binary representation with a top level type of 0x1. They have a payload consisting of one or more Binary Data Types (<xref target="types" format="default"/>) representing the members of the list.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Binary Data Type (..) ...
}
]]></artwork>
        </section>
        <section anchor="dictionary-field-values" numbered="true" toc="default">
          <name>Dictionary Field Values</name>
          <t>Structured fields whose values are known to be a Dictionary as per <xref section="3.2" sectionFormat="of" target="RFC8941" format="default"/> can be conveyed in a binary representation with a top level type of 0x2. They have a payload consisting of one or more Dictionary Members.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
]]></artwork>
          <t>Each Dictionary member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Data Type(s) representing the member-value.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Binary Data Type (..),
  [Parameters (..)]
}

]]></artwork>
          <t>The Binary Data Type in a Dictionary Member MUST NOT be a Parameters (0x2).</t>
        </section>
        <section anchor="item-field-values" numbered="true" toc="default">
          <name>Item Field Values</name>
          <t>Structured field values that are known to be an Item as per <xref section="3.3" sectionFormat="of" target="RFC8941" format="default"/> can be conveyed in a binary representation with a top level type of 0x3. They have a payload consisting of a single Binary Data Type (<xref target="types" format="default"/>), with optional parameters (<xref target="parameter" format="default"/>).</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Binary Data Type (..),
  [Parameters (..)]
}
]]></artwork>
          <t>The Binary Data Type in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
        </section>
      </section>
      <section anchor="types" numbered="true" toc="default">
        <name>Binary Data Types</name>
        <t>Binary data types are discrete values that are composed into binary representations (<xref target="binlit" format="default"/>) to represent the structured field values.</t>
        <t>Every binary data type starts with a 4-bit type field that identifies the format of its payload.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Data Type {
  Type (4)
}
]]></artwork>
        <t>Some data types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>
        <section anchor="inner-list" numbered="true" toc="default">
          <name>Inner Lists</name>
          <t>The Inner List data type (type=0x1) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Inner List {
  Type (4) = 1,
  Length (4..),
  Binary Data Type (..) ...
}
]]></artwork>
          <t>Length conveys the number of octets used to represent the inner list, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 4-bit prefix.</t>
          <t>A Binary Data Type in an Inner List MUST NOT be an Inner List (0x1).</t>
          <t>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<xref target="parameter" format="default"/>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</t>
        </section>
        <section anchor="parameter" numbered="true" toc="default">
          <name>Parameters</name>
          <t>The Parameters data type (type=0x2) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameters {
  Type (4) = 2,
  Length (4..),
  Parameter (..) ...
}
]]></artwork>
          <t>Length conveys the number of octets used to represent the parameters, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 4-bit prefix.</t>
          <t>Each Parameter conveys a key and a value:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Binary Data Type (..)
}
]]></artwork>
          <t>A parameter's fields are:</t>
          <ul spacing="normal">
            <li>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 8-bit prefix</li>
            <li>Parameter Name: Parameter Name Length octets of the parameter-name</li>
            <li>Binary Data Type: The parameter value, a Binary Data Type</li>
          </ul>
          <t>The Binary Data Type in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
          <t>Parameters are always associated with the Binary Data Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Binary Data Type in a Binary Representation, and MUST NOT follow another Parameters.</t>
        </section>
        <section anchor="integers" numbered="true" toc="default">
          <name>Integers</name>
          <t>The Integer data type (type=0x3) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Integer {
  Type (4) = 3,
  Sign (1),
  Payload (3..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Payload: The integer, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 2-bit prefix</li>
          </ul>
        </section>
        <section anchor="floats" numbered="true" toc="default">
          <name>Floats</name>
          <t>The Float data type (type=0x4) have a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Float {
  Type (4) = 4,
  Sign (1),
  Integer (3..),
  Fractional (8..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Integer: The integer component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 2-bit prefix.</li>
            <li>Fractional: The fractional component, encoded as per <xref section="5.1" sectionFormat="of" target="RFC7541" format="default"/>, with a 8-bit prefix.</li>
          </ul>
        </section>
        <section anchor="strings" numbered="true" toc="default">
          <name>Strings</name>
          <t>The String data type (type=0x5) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
String {
  Type (4) = 5,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>Its payload is Length octets long and ASCII-encoded.</t>
        </section>
        <section anchor="token" numbered="true" toc="default">
          <name>Tokens</name>
          <t>The Token data type (type=0x6) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Token {
  Type (4) = 6,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>Its payload is Length octets long and ASCII-encoded.</t>
        </section>
        <section anchor="byte-sequences" numbered="true" toc="default">
          <name>Byte Sequences</name>
          <t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Byte Sequence {
  Type (4) = 7,
  Length (4..),
  Payload (..)
}
]]></artwork>
          <t>The payload is is Length octets long, containing the raw octets of the byte sequence.</t>
        </section>
        <section anchor="booleans" numbered="true" toc="default">
          <name>Booleans</name>
          <t>The Boolean data type (type=0x8) has a payload of two bits:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Boolean {
  Type (4) = 8,
  Payload (1),
  Padding (3) = 0
}
]]></artwork>
          <t>If Payload is 0, the value is False; if Payload is 1, the value is True.</t>
        </section>
      </section>
    </section>
    <section anchor="negotiate" numbered="true" toc="default">
      <name>Using Binary Structured Fields in HTTP/2</name>
      <t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields (or compatible with them; see <xref target="backport" format="default"/>) as binary data, rather than strings.</t>
      <t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting" format="default"/>, and convey Binary Structured Fields in streams whose HEADERS frame uses the flag defined in <xref target="flag" format="default"/>.</t>
      <section anchor="setting" numbered="true" toc="default">
        <name>The SETTINGS_BINARY_STRUCTURED_FIELDS Setting</name>
        <t>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</t>
        <t>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS with a non-zero value from a peer indicates that:</t>
        <ol spacing="normal" type="1"><li>The peer supports the Binary Data Types defined in <xref target="fields" format="default"/>.</li>
          <li>The peer will process the BINARY_STRUCTRED HEADERS flag as defined in <xref target="flag" format="default"/>.</li>
          <li>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Fields data types defined in <xref target="RFC8941" format="default"/>).</li>
          <li>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased" format="default"/>) into their non-aliased forms as necessary.</li>
        </ol>
        <t>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0, whereas a value of 1 indicates that this specification is supported with no further extensions. Future specifications might use values greater than one to indicate support for extensions.</t>
      </section>
      <section anchor="flag" numbered="true" toc="default">
        <name>The BINARY_STRUCTRED HEADERS Flag</name>
        <t>When a peer has indicated that it supports this specification as per <xref target="setting" format="default"/>, a sender can send the BINARY_STRUCTURED flag (0xTODO) on the HEADERS frame.</t>
        <t>This flag indicates that the HEADERS frame containing it and subsequent CONTINUATION frames on the same stream use the Binary Representation defined in <xref target="binlit" format="default"/> instead of the String Literal Representation defined in <xref section="5.2" sectionFormat="of" target="RFC7541" format="default"/> for all field values. Field names are still serialised as String Literal Representations.</t>
        <t>In such frames, field values that are known to be Structured Fields and those that can be converted to Structured Fields (as per <xref target="backport" format="default"/>) MAY be sent using the applicable Binary Representation. However, any field value (including those defined as Structured Fields) can also be serialised as a Binary Literal (<xref target="literal" format="default"/>) to accommodate fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as a Structured Field for some other reason.</t>
        <t>Binary Representations are stored in the HPACK <xref target="RFC7541" format="default"/> dynamic table, and their lengths are used for the purposes of maintaining dynamic table size (<xref section="4" sectionFormat="comma" target="RFC7541" format="default"/>).</t>
        <t>Note that HEADERS frames with and without the BINARY_STRUCTURED flag MAY be mixed on the same connection, depending on the requirements of the sender.</t>
      </section>
    </section>
    <section anchor="backport" numbered="true" toc="default">
      <name>Using Binary Structured Fields with Existing Fields</name>
      <t>Any field can potentially be parsed as a Structured Field according to the algorithms in <xref target="RFC8941" format="default"/> and serialised as a Binary Structured Field. However, many cannot, so optimistically parsing them can be expensive.</t>
      <t>This section identifies fields that will usually succeed in <xref target="direct" format="default"/>, and those that can be mapped into Structured Fields by using an alias field name in <xref target="aliased" format="default"/>.</t>
      <section anchor="direct" numbered="true" toc="default">
        <name>Directly Represented Fields</name>
        <t>The following HTTP field names can have their values parsed as Structured Fields according to the algorithms in <xref target="RFC8941" format="default"/>, and thus can usually be serialised using the corresponding Binary Data Types.</t>
        <t>When one of these fields' values cannot be represented using Structured Types in a Binary Representation, its value can instead be represented as a Binary Literal (<xref target="literal" format="default"/>).</t>
        <ul spacing="normal">
          <li>Accept - List</li>
          <li>Accept-Encoding - List</li>
          <li>Accept-Language - List</li>
          <li>Accept-Patch - List</li>
          <li>Accept-Ranges - List</li>
          <li>Access-Control-Allow-Credentials - Item</li>
          <li>Access-Control-Allow-Headers - List</li>
          <li>Access-Control-Allow-Methods - List</li>
          <li>Access-Control-Allow-Origin - Item</li>
          <li>Access-Control-Max-Age - Item</li>
          <li>Access-Control-Request-Headers - List</li>
          <li>Access-Control-Request-Method - Item</li>
          <li>Age - Item</li>
          <li>Allow - List</li>
          <li>ALPN - List</li>
          <li>Alt-Svc - Dictionary</li>
          <li>Alt-Used - Item</li>
          <li>Cache-Control - Dictionary</li>
          <li>Connection - List</li>
          <li>Content-Encoding - List</li>
          <li>Content-Language - List</li>
          <li>Content-Length - Item</li>
          <li>Content-Type - Item</li>
          <li>Expect - Item</li>
          <li>Expect-CT - Dictionary</li>
          <li>Forwarded - Dictionary</li>
          <li>Host - Item</li>
          <li>Keep-Alive - Dictionary</li>
          <li>Origin - Item</li>
          <li>Pragma - Dictionary</li>
          <li>Prefer - Dictionary</li>
          <li>Preference-Applied - Dictionary</li>
          <li>Retry-After - Item  (see caveat below)</li>
          <li>Surrogate-Control - Dictionary</li>
          <li>TE - List</li>
          <li>Trailer - List</li>
          <li>Transfer-Encoding - List</li>
          <li>Vary - List</li>
          <li>X-Content-Type-Options - Item</li>
          <li>X-XSS-Protection - List</li>
        </ul>
        <t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Binary Literal (<xref target="literal" format="default"/>).</t>
      </section>
      <section anchor="aliased" numbered="true" toc="default">
        <name>Aliased Fields</name>
        <t>The following HTTP field names can have their values represented in Structured Fields by mapping them into its data types and then serialising the resulting Structured Field using an alternative field name.</t>
        <t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork>
        <t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured Fields as:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Date: 784072177
]]></artwork>
        <t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Binary Literal (<xref target="literal" format="default"/>).</t>
        <t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate" format="default"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>
        <t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Fields.</t>
        <ul spacing="normal">
          <li>ISSUE: using separate names assures that the different syntax doesn't "leak" into normal fields, but it isn't strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn't understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></li>
        </ul>
        <section anchor="urls" numbered="true" toc="default">
          <name>URLs</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by considering their payload a string.</t>
          <ul spacing="normal">
            <li>Content-Location - SF-Content-Location</li>
            <li>Location - SF-Location</li>
            <li>Referer - SF-Referer</li>
          </ul>
          <t>For example, a (non-binary) Location:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Location: "https://example.com/foo"
]]></artwork>
          <t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>
        </section>
        <section anchor="dates" numbered="true" toc="default">
          <name>Dates</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by parsing their payload according to <xref target="RFC7231" format="default"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>
          <ul spacing="normal">
            <li>Date - SF-Date</li>
            <li>Expires - SF-Expires</li>
            <li>If-Modified-Since - SF-IMS</li>
            <li>If-Unmodified-Since - SF-IUS</li>
            <li>Last-Modified - SF-LM</li>
          </ul>
          <t>For example, a (non-binary) Expires:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Expires: 1571965240
]]></artwork>
        </section>
        <section anchor="etags" numbered="true" toc="default">
          <name>ETags</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by representing the entity-tag as a string, and the weakness flag as a boolean "w" parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>
          <ul spacing="normal">
            <li>ETag - SF-ETag</li>
          </ul>
          <t>For example, a (non-Binary) ETag:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-ETag: "abcdef"; w=?1
]]></artwork>
          <t>If-None-Match is a list of the structure described above.</t>
          <ul spacing="normal">
            <li>If-None-Match - SF-INM</li>
          </ul>
          <t>For example, a (non-binary) If-None-Match:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork>
        </section>
        <section anchor="links" numbered="true" toc="default">
          <name>Links</name>
          <t>The field-value of the Link header field <xref target="RFC8288" format="default"/> can be represented in Binary Structured Fields by representing the URI-Reference as a string, and link-param as parameters.</t>
          <ul spacing="normal">
            <li>Link: SF-Link</li>
          </ul>
          <t>For example, a (non-binary) Link:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork>
        </section>
        <section anchor="cookies" numbered="true" toc="default">
          <name>Cookies</name>
          <t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265" format="default"/> can be represented in Binary Structured Fields as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>
          <t>Set-Cookie: SF-Set-Cookie
Cookie: SF-Cookie</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SF-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork>
          <ul spacing="normal">
            <li>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></li>
            <li>ISSUE: dictionary keys cannot contain UC alpha. <eref target="https://github.com/mnot/I-D/issues/312">https://github.com/mnot/I-D/issues/312</eref></li>
            <li>ISSUE: explicitly allow non-string content. <eref target="https://github.com/mnot/I-D/issues/313">https://github.com/mnot/I-D/issues/313</eref></li>
          </ul>
        </section>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <ul spacing="normal">
        <li>ISSUE: todo</li>
      </ul>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>
      <t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of Binary Literals (<xref target="literal" format="default"/>). Therefore, implementation divergence from this strictness can have security impact.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author fullname="S. Bradner" initials="S." surname="Bradner">
            <organization/>
          </author>
          <date month="March" year="1997"/>
          <abstract>
            <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <seriesInfo name="DOI" value="10.17487/RFC2119"/>
      </reference>
      <reference anchor="RFC7541" target="https://www.rfc-editor.org/info/rfc7541">
        <front>
          <title>HPACK: Header Compression for HTTP/2</title>
          <author fullname="R. Peon" initials="R." surname="Peon">
            <organization/>
          </author>
          <author fullname="H. Ruellan" initials="H." surname="Ruellan">
            <organization/>
          </author>
          <date month="May" year="2015"/>
          <abstract>
            <t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7541"/>
        <seriesInfo name="DOI" value="10.17487/RFC7541"/>
      </reference>
      <reference anchor="I-D.ietf-quic-transport" target="https://www.ietf.org/archive/id/draft-ietf-quic-transport-34.txt">
        <front>
          <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
          <author fullname="Jana Iyengar">
            <organization>Fastly</organization>
          </author>
          <author fullname="Martin Thomson">
            <organization>Mozilla</organization>
          </author>
          <date day="14" month="January" year="2021"/>
          <abstract>
            <t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration.  QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.
            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-quic-transport-34"/>
      </reference>
      <reference anchor="RFC8941" target="https://www.rfc-editor.org/info/rfc8941">
        <front>
          <title>Structured Field Values for HTTP</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <author fullname="P-H. Kamp" initials="P-H." surname="Kamp">
            <organization/>
          </author>
          <date month="February" year="2021"/>
          <abstract>
            <t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8941"/>
        <seriesInfo name="DOI" value="10.17487/RFC8941"/>
      </reference>
      <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174">
        <front>
          <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
          <author fullname="B. Leiba" initials="B." surname="Leiba">
            <organization/>
          </author>
          <date month="May" year="2017"/>
          <abstract>
            <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="8174"/>
        <seriesInfo name="DOI" value="10.17487/RFC8174"/>
      </reference>
      <reference anchor="RFC7231" target="https://www.rfc-editor.org/info/rfc7231">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
          <author fullname="R. Fielding" initials="R." role="editor" surname="Fielding">
            <organization/>
          </author>
          <author fullname="J. Reschke" initials="J." role="editor" surname="Reschke">
            <organization/>
          </author>
          <date month="June" year="2014"/>
          <abstract>
            <t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7231"/>
        <seriesInfo name="DOI" value="10.17487/RFC7231"/>
      </reference>
      <reference anchor="RFC8288" target="https://www.rfc-editor.org/info/rfc8288">
        <front>
          <title>Web Linking</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <date month="October" year="2017"/>
          <abstract>
            <t>This specification defines a model for the relationships between resources on the Web ("links") and the type of those relationships ("link relation types").</t>
            <t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8288"/>
        <seriesInfo name="DOI" value="10.17487/RFC8288"/>
      </reference>
      <reference anchor="RFC6265" target="https://www.rfc-editor.org/info/rfc6265">
        <front>
          <title>HTTP State Management Mechanism</title>
          <author fullname="A. Barth" initials="A." surname="Barth">
            <organization/>
          </author>
          <date month="April" year="2011"/>
          <abstract>
            <t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="6265"/>
        <seriesInfo name="DOI" value="10.17487/RFC6265"/>
      </reference>
    </references>
    <section anchor="data-supporting-directly-represented-field-mappings" numbered="true" toc="default">
      <name>Data Supporting Directly Represented Field Mappings</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>To help guide decisions about Directly Represented Fields, the HTTP response headers captured by the HTTP Archive <eref target="https://httparchive.org">https://httparchive.org</eref> in February 2020, representing more than 350,000,000 HTTP exchanges, were parsed as Structured Fields using the types listed in <xref target="direct" format="default"/>, with the indicated number of successful header instances, failures, and the resulting failure rate:</t>
      <ul spacing="normal">
        <li>accept: 9,198 / 10 = 0.109%</li>
        <li>accept-encoding: 34,157 / 74 = 0.216%</li>
        <li>accept-language: 381,034 / 512 = 0.134%</li>
        <li>accept-patch: 5 / 0 = 0.000%</li>
        <li>accept-ranges: 197,746,643 / 3,960 = 0.002%</li>
        <li>access-control-allow-credentials: 16,684,916 / 7,438 = 0.045%</li>
        <li>access-control-allow-headers: 12,976,838 / 15,074 = 0.116%</li>
        <li>access-control-allow-methods: 15,466,748 / 28,203 = 0.182%</li>
        <li>access-control-allow-origin: 105,307,402 / 271,359 = 0.257%</li>
        <li>access-control-max-age: 5,284,663 / 7,754 = 0.147%</li>
        <li>access-control-request-headers: 39,328 / 624 = 1.562%</li>
        <li>access-control-request-method: 146,259 / 13,821 = 8.634%</li>
        <li>age: 71,281,684 / 172,398 = 0.241%</li>
        <li>allow: 351,704 / 1,886 = 0.533%</li>
        <li>alt-svc: 19,775,126 / 15,680,528 = 44.226%</li>
        <li>cache-control: 264,805,256 / 782,896 = 0.295%</li>
        <li>connection: 105,876,072 / 2,915 = 0.003%</li>
        <li>content-encoding: 139,799,523 / 379 = 0.000%</li>
        <li>content-language: 2,367,162 / 728 = 0.031%</li>
        <li>content-length: 296,624,718 / 787,843 = 0.265%</li>
        <li>content-type: 341,918,716 / 795,676 = 0.232%</li>
        <li>expect: 0 / 47 = 100.000%</li>
        <li>expect-ct: 26,569,605 / 29,114 = 0.109%</li>
        <li>forwarded: 119 / 35 = 22.727%</li>
        <li>host: 25,333 / 1,441 = 5.382%</li>
        <li>keep-alive: 43,061,546 / 796 = 0.002%</li>
        <li>origin: 24,335 / 1,539 = 5.948%</li>
        <li>pragma: 46,820,588 / 81,700 = 0.174%</li>
        <li>preference-applied: 57 / 0 = 0.000%</li>
        <li>retry-after: 605,844 / 6,195 = 1.012%</li>
        <li>strict-transport-security: 26,825,957 / 35,258,808 = 56.791%</li>
        <li>surrogate-control: 121,118 / 861 = 0.706%</li>
        <li>te: 1 / 0 = 0.000%</li>
        <li>trailer: 282 / 0 = 0.000%</li>
        <li>transfer-encoding: 13,952,661 / 0 = 0.000%</li>
        <li>vary: 150,787,199 / 41,313 = 0.027%</li>
        <li>x-content-type-options: 99,968,016 / 208,885 = 0.209%</li>
        <li>x-xss-protection: 79,871,948 / 362,979 = 0.452%</li>
      </ul>
      <t>This data set focuses on response headers, although some request headers are present (because, the Web).</t>
      <t><tt>alt-svc</tt> has a high failure rate because some currently-used ALPN tokens (e.g., <tt>h3-Q43</tt>) do not conform to key's syntax. Since the final version of HTTP/3 will use the <tt>h3</tt> token, this shouldn't be a long-term issue, although future tokens may again violate this assumption.</t>
      <t><tt>forwarded</tt> has a high failure rate because many senders use the unquoted form for IP addresses, which makes integer parsing fail; e.g., <tt>for=192.168.1.1</tt>.</t>
      <t><tt>strict-transport-security</tt> has a high failure rate because the <tt>includeSubDomains</tt> flag does not conform to the key syntax.</t>
      <t>The top ten header fields in that data set that were not parsed as Directly Represented Fields are:</t>
      <ul spacing="normal">
        <li>date: 354,652,447</li>
        <li>server: 311,275,961</li>
        <li>last-modified: 263,832,615</li>
        <li>expires: 199,967,042</li>
        <li>status: 192,423,509</li>
        <li>etag: 172,058,269</li>
        <li>timing-allow-origin: 64,407,586</li>
        <li>x-cache: 41,740,804</li>
        <li>p3p: 39,490,058</li>
        <li>x-frame-options: 34,037,985</li>
      </ul>
    </section>
  </back>
  <!-- ##markdown-source:
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
akDo2OkOnfGoT1dzWv8LdCgu1gNaAAA=

-->

</rfc>
